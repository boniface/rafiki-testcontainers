"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReplyBuilder = exports.base64url = exports.decrypt = exports.encrypt = exports.hmac = exports.sha256 = void 0;
const packet_1 = require("ilp-protocol-stream/dist/src/packet");
const long_1 = __importDefault(require("long"));
const ilp_packet_1 = require("ilp-packet");
const long_2 = require("ilp-protocol-stream/dist/src/util/long");
const crypto_1 = require("crypto");
const crypto_2 = require("ilp-protocol-stream/dist/src/crypto");
const HASH_ALGORITHM = 'sha256';
const ENCRYPTION_ALGORITHM = 'aes-256-gcm';
const IV_LENGTH = 12;
const AUTH_TAG_LENGTH = 16;
const sha256 = (preimage) => (0, crypto_1.createHash)(HASH_ALGORITHM).update(preimage).digest();
exports.sha256 = sha256;
const hmac = (key, message) => (0, crypto_1.createHmac)(HASH_ALGORITHM, key).update(message).digest();
exports.hmac = hmac;
const encrypt = (key, plaintext) => {
    const iv = (0, crypto_2.randomBytes)(12);
    const cipher = (0, crypto_1.createCipheriv)(ENCRYPTION_ALGORITHM, key, iv);
    const ciphertext = [];
    ciphertext.push(cipher.update(plaintext));
    ciphertext.push(cipher.final());
    const tag = cipher.getAuthTag();
    ciphertext.unshift(iv, tag);
    return Buffer.concat(ciphertext);
};
exports.encrypt = encrypt;
const decrypt = (key, ciphertext) => {
    const nonce = ciphertext.slice(0, IV_LENGTH);
    const tag = Buffer.alloc(AUTH_TAG_LENGTH);
    ciphertext.copy(tag, 0, IV_LENGTH, IV_LENGTH + AUTH_TAG_LENGTH);
    const encrypted = ciphertext.slice(IV_LENGTH + AUTH_TAG_LENGTH);
    const decipher = (0, crypto_1.createDecipheriv)(ENCRYPTION_ALGORITHM, key, nonce);
    decipher.setAuthTag(tag);
    return Buffer.concat([decipher.update(encrypted), decipher.final()]);
};
exports.decrypt = decrypt;
const base64url = (buffer) => buffer.toString('base64').replace(/=+$/, '').replace(/\+/g, '-').replace(/\//g, '_');
exports.base64url = base64url;
class ReplyBuilder {
    constructor() {
        this.sequence = long_1.default.UZERO;
        this.receivedAmount = long_1.default.UZERO;
        this.frames = [];
        this.ilpAddress = '';
    }
    setIlpAddress(ilpAddress) {
        this.ilpAddress = ilpAddress;
        return this;
    }
    setEncryptionKey(key) {
        this.encryptionKey = key;
        return this;
    }
    setSequence(sequence) {
        this.sequence = sequence;
        return this;
    }
    setReceivedAmount(receivedAmount) {
        this.receivedAmount = (0, long_2.longFromValue)(receivedAmount, true);
        return this;
    }
    addFrames(...frames) {
        this.frames.push(...frames);
        return this;
    }
    buildData(type) {
        if (!this.encryptionKey) {
            return Buffer.alloc(0);
        }
        const streamPacket = new packet_1.Packet(this.sequence, +type, this.receivedAmount, this.frames)._serialize();
        return (0, exports.encrypt)(this.encryptionKey, streamPacket);
    }
    buildFulfill(fulfillment) {
        return {
            fulfillment,
            data: this.buildData(ilp_packet_1.IlpPacketType.Fulfill),
        };
    }
    buildReject(code) {
        return {
            code,
            message: '',
            triggeredBy: this.ilpAddress,
            data: this.buildData(ilp_packet_1.IlpPacketType.Reject),
        };
    }
}
exports.ReplyBuilder = ReplyBuilder;
//# sourceMappingURL=utils.js.map