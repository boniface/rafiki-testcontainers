"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PacingController = void 0;
const _1 = require("@interledger/pay/dist/src/controllers");
const utils_1 = require("@interledger/pay/dist/src/utils");
class PacingController {
    constructor() {
        this.lastPacketSentTime = 0;
        this.averageRoundTrip = PacingController.DEFAULT_ROUND_TRIP_TIME_MS;
        this.packetsPerSecond = PacingController.DEFAULT_PACKETS_PER_SECOND;
        this.inFlightCount = 0;
    }
    getPacketFrequency() {
        const packetsPerSecondDelay = 1000 / this.packetsPerSecond;
        const maxInFlightDelay = this.averageRoundTrip / PacingController.MAX_INFLIGHT_PACKETS;
        return Math.max(packetsPerSecondDelay, maxInFlightDelay);
    }
    getNextPacketSendTime() {
        const delayDuration = this.getPacketFrequency();
        return this.lastPacketSentTime + delayDuration;
    }
    buildRequest() {
        const durationUntilNextPacket = this.getNextPacketSendTime() - Date.now();
        return durationUntilNextPacket > 0
            ? _1.RequestState.Schedule((0, utils_1.sleep)(durationUntilNextPacket))
            : this.inFlightCount >= PacingController.MAX_INFLIGHT_PACKETS
                ? _1.RequestState.Yield()
                : _1.RequestState.Ready();
    }
    applyRequest() {
        const sentTime = Date.now();
        this.lastPacketSentTime = sentTime;
        this.inFlightCount++;
        return (reply) => {
            this.inFlightCount--;
            if (reply.isAuthentic()) {
                const roundTripTime = Math.max(Date.now() - sentTime, 0);
                this.averageRoundTrip =
                    this.averageRoundTrip * PacingController.ROUND_TRIP_AVERAGE_WEIGHT +
                        roundTripTime * (1 - PacingController.ROUND_TRIP_AVERAGE_WEIGHT);
            }
            if (reply.isReject() && reply.ilpReject.code[0] === 'T') {
                const reducedRate = Math.max(PacingController.MIN_PACKETS_PER_SECOND, this.packetsPerSecond * PacingController.PACKETS_PER_SECOND_DECREASE_FACTOR);
                reply.log.debug('handling %s. backing off to %s packets / second', reply.ilpReject.code, reducedRate.toFixed(3));
                this.packetsPerSecond = reducedRate;
            }
            else if (reply.isAuthentic()) {
                this.packetsPerSecond = Math.min(PacingController.MAX_PACKETS_PER_SECOND, this.packetsPerSecond + PacingController.PACKETS_PER_SECOND_INCREASE_TERM);
            }
        };
    }
}
exports.PacingController = PacingController;
PacingController.DEFAULT_PACKETS_PER_SECOND = 40;
PacingController.MIN_PACKETS_PER_SECOND = 1;
PacingController.MAX_PACKETS_PER_SECOND = 200;
PacingController.PACKETS_PER_SECOND_INCREASE_TERM = 0.5;
PacingController.PACKETS_PER_SECOND_DECREASE_FACTOR = 0.5;
PacingController.DEFAULT_ROUND_TRIP_TIME_MS = 200;
PacingController.ROUND_TRIP_AVERAGE_WEIGHT = 0.9;
PacingController.MAX_INFLIGHT_PACKETS = 20;
//# sourceMappingURL=pacer.js.map