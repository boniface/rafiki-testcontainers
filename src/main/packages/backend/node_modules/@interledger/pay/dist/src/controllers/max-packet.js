"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MaxPacketAmountController = void 0;
const oer_utils_1 = require("oer-utils");
const utils_1 = require("@interledger/pay/dist/src/utils");
const __1 = require("@interledger/pay");
const ilp_packet_1 = require("ilp-packet");
const rate_probe_1 = require("@interledger/pay/dist/src/senders/rate-probe");
var MaxPacketState;
(function (MaxPacketState) {
    MaxPacketState[MaxPacketState["UnknownMax"] = 0] = "UnknownMax";
    MaxPacketState[MaxPacketState["PreciseMax"] = 1] = "PreciseMax";
    MaxPacketState[MaxPacketState["ImpreciseMax"] = 2] = "ImpreciseMax";
})(MaxPacketState || (MaxPacketState = {}));
class MaxPacketAmountController {
    constructor(preciseMaxPacketAmount) {
        this.verifiedPathCapacity = utils_1.Int.ZERO;
        this.state = preciseMaxPacketAmount
            ? {
                type: MaxPacketState.PreciseMax,
                maxPacketAmount: preciseMaxPacketAmount,
            }
            : {
                type: MaxPacketState.UnknownMax,
            };
    }
    getNextMaxPacketAmount() {
        switch (this.state.type) {
            case MaxPacketState.PreciseMax:
                return this.state.maxPacketAmount;
            case MaxPacketState.ImpreciseMax:
                return this.state.maxPacketAmount
                    .saturatingSubtract(this.verifiedPathCapacity)
                    .divideCeil(utils_1.Int.TWO)
                    .add(this.verifiedPathCapacity);
            case MaxPacketState.UnknownMax:
                return undefined;
        }
    }
    isProbeComplete() {
        const verifiedPreciseMax = this.state.type === MaxPacketState.PreciseMax &&
            this.verifiedPathCapacity.isEqualTo(this.state.maxPacketAmount);
        const verifiedLargeCapacity = this.state.type === MaxPacketState.UnknownMax &&
            this.verifiedPathCapacity.isGreaterThanOrEqualTo(rate_probe_1.RateProbe.MAX_PROBE_AMOUNT);
        return verifiedPreciseMax || verifiedLargeCapacity;
    }
    getMaxPacketAmountLimit() {
        return this.state.type === MaxPacketState.UnknownMax ? utils_1.Int.MAX_U64 : this.state.maxPacketAmount;
    }
    applyRequest({ sourceAmount }) {
        return (reply) => {
            if (reply.isReject() && reply.ilpReject.code === ilp_packet_1.IlpError.F08_AMOUNT_TOO_LARGE) {
                return this.reduceMaxPacketAmount(reply, sourceAmount);
            }
            else if (reply.isAuthentic()) {
                this.adjustPathCapacity(reply.log, sourceAmount);
            }
        };
    }
    reduceMaxPacketAmount(reply, sourceAmount) {
        const { log, ilpReject } = reply;
        let newMax;
        let isPreciseMax;
        try {
            const reader = oer_utils_1.Reader.from(ilpReject.data);
            const remoteReceived = utils_1.Int.from(reader.readUInt64Long());
            const remoteMaximum = utils_1.Int.from(reader.readUInt64Long());
            log.debug('handling F08. remote received: %s, remote max: %s', remoteReceived, remoteMaximum);
            if (!remoteReceived.isGreaterThan(remoteMaximum)) {
                return;
            }
            const exchangeRate = utils_1.Ratio.of(sourceAmount, remoteReceived);
            newMax = remoteMaximum.multiplyFloor(exchangeRate);
            isPreciseMax = true;
        }
        catch (_) {
            log.debug('handling F08 without metadata. source amount: %s', sourceAmount);
            newMax = sourceAmount.saturatingSubtract(utils_1.Int.ONE);
            isPreciseMax = false;
        }
        if (!newMax.isPositive()) {
            log.debug('ending payment: max packet amount is 0, cannot send over path');
            return __1.PaymentError.ConnectorError;
        }
        if (this.state.type === MaxPacketState.UnknownMax) {
            log.debug('setting initial max packet amount to %s', newMax);
        }
        else if (newMax.isLessThan(this.state.maxPacketAmount)) {
            log.debug('reducing max packet amount from %s to %s', this.state.maxPacketAmount, newMax);
        }
        else {
            return;
        }
        this.state = {
            type: isPreciseMax ? MaxPacketState.PreciseMax : MaxPacketState.ImpreciseMax,
            maxPacketAmount: newMax,
        };
        this.adjustPathCapacity(log, this.verifiedPathCapacity);
    }
    adjustPathCapacity(log, ackAmount) {
        const newPathCapacity = this.verifiedPathCapacity
            .orGreater(ackAmount)
            .orLesser(this.getMaxPacketAmountLimit());
        if (newPathCapacity.isGreaterThan(this.verifiedPathCapacity)) {
            log.debug('increasing greatest path packet amount from %s to %s', this.verifiedPathCapacity, newPathCapacity);
        }
        this.verifiedPathCapacity = newPathCapacity;
        if (this.state.type === MaxPacketState.ImpreciseMax &&
            this.verifiedPathCapacity.isEqualTo(this.state.maxPacketAmount)) {
            log.debug('discovered precise max packet amount: %s', this.state.maxPacketAmount);
            this.state = {
                type: MaxPacketState.PreciseMax,
                maxPacketAmount: this.state.maxPacketAmount,
            };
        }
    }
}
exports.MaxPacketAmountController = MaxPacketAmountController;
//# sourceMappingURL=max-packet.js.map