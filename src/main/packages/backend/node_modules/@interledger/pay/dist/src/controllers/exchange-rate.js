"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExchangeRateController = void 0;
const utils_1 = require("@interledger/pay/dist/src/utils");
class ExchangeRateController {
    constructor(lowerBoundRate = utils_1.Ratio.of(utils_1.Int.ZERO, utils_1.Int.ONE), upperBoundRate = utils_1.Ratio.of(utils_1.Int.MAX_U64, utils_1.Int.ONE)) {
        this.lowerBoundRate = lowerBoundRate;
        this.upperBoundRate = upperBoundRate;
    }
    applyRequest({ sourceAmount, log }) {
        return ({ destinationAmount }) => {
            if (!sourceAmount.isPositive()) {
                return;
            }
            if (!destinationAmount) {
                return;
            }
            const packetUpperBoundRate = utils_1.Ratio.of(destinationAmount.add(utils_1.Int.ONE), sourceAmount);
            const packetLowerBoundRate = utils_1.Ratio.of(destinationAmount, sourceAmount);
            const shouldResetExchangeRate = packetUpperBoundRate.isLessThanOrEqualTo(this.lowerBoundRate) ||
                packetLowerBoundRate.isGreaterThanOrEqualTo(this.upperBoundRate);
            if (shouldResetExchangeRate) {
                log.debug('exchange rate changed. resetting to [%s, %s]', packetLowerBoundRate, packetUpperBoundRate);
                this.upperBoundRate = packetUpperBoundRate;
                this.lowerBoundRate = packetLowerBoundRate;
                return;
            }
            if (packetLowerBoundRate.isGreaterThan(this.lowerBoundRate)) {
                log.debug('increasing probed rate lower bound from %s to %s', this.lowerBoundRate, packetLowerBoundRate);
                this.lowerBoundRate = packetLowerBoundRate;
            }
            if (packetUpperBoundRate.isLessThan(this.upperBoundRate)) {
                log.debug('reducing probed rate upper bound from %s to %s', this.upperBoundRate, packetUpperBoundRate);
                this.upperBoundRate = packetUpperBoundRate;
            }
        };
    }
    getLowerBoundRate() {
        return this.lowerBoundRate;
    }
    getUpperBoundRate() {
        return this.upperBoundRate;
    }
    estimateDestinationAmount(sourceAmount) {
        const lowEndDestination = sourceAmount.multiplyFloor(this.lowerBoundRate).orLesser(utils_1.Int.MAX_U64);
        const highEndDestination = sourceAmount
            .multiplyCeil(this.upperBoundRate)
            .saturatingSubtract(utils_1.Int.ONE)
            .orLesser(utils_1.Int.MAX_U64);
        return [lowEndDestination, highEndDestination];
    }
    estimateSourceAmount(destinationAmount) {
        const lowerBoundRate = this.lowerBoundRate.reciprocal();
        if (!lowerBoundRate) {
            return;
        }
        const lowEndSource = destinationAmount
            .multiplyFloor(this.upperBoundRate.reciprocal())
            .add(utils_1.Int.ONE);
        const highEndSource = destinationAmount.multiplyCeil(lowerBoundRate);
        return [lowEndSource, highEndSource];
    }
}
exports.ExchangeRateController = ExchangeRateController;
//# sourceMappingURL=exchange-rate.js.map