{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { isValidAssetScale } from 'ilp-protocol-ildcp'\nimport { Writer, Reader } from 'oer-utils'\nimport createLogger from 'ilp-logger'\nimport {\n  IlpReject,\n  IlpPrepare,\n  IlpFulfill,\n  IlpPacketType,\n  IlpAddress,\n  isValidIlpAddress,\n  IlpError,\n  IlpReply,\n} from 'ilp-packet'\nimport { hmac, sha256, base64url, ReplyBuilder, decrypt, encrypt } from './utils'\nimport {\n  Packet,\n  ConnectionCloseFrame,\n  FrameType,\n  ErrorCode,\n  ConnectionAssetDetailsFrame,\n  StreamReceiptFrame,\n} from 'ilp-protocol-stream/dist/src/packet'\nimport { LongValue } from 'ilp-protocol-stream/dist/src/util/long'\nimport { createReceipt } from 'ilp-protocol-stream/dist/src/util/receipt'\nimport Long from 'long'\n\n/** Parameters to statelessly generate new STREAM connections and handle incoming packets for STREAM connections. */\nexport interface ServerOptions {\n  /** Secret used to statelessly generate credentials for incoming STREAM connections. */\n  serverSecret: Buffer\n\n  /** Base ILP address of this STREAM server to access it over the Interledger network. */\n  serverAddress: string\n}\n\n/** Credentials for a client to setup a STREAM connection with a STREAM server */\nexport interface StreamCredentials {\n  /** ILP address of the recipient account, identifying this connection, for the client to send packets to this STREAM server. */\n  ilpAddress: IlpAddress\n\n  /** 32-byte seed to encrypt and decrypt STREAM messages, and generate ILP packet fulfillments. */\n  sharedSecret: Buffer\n}\n\n/** Pending STREAM request and in-flight ILP Prepare with funds that may be fulfilled or rejected. */\nexport interface IncomingMoney {\n  /** Unique identifier of this STREAM connection: SHA-256 hash of destination ILP address with token, hex-encoded */\n  connectionId: string\n\n  /** Arbitrary data to attribute or handle an incoming payment, encoded when the credentials were generated. */\n  paymentTag?: string\n\n  /**\n   * Sign and include and STREAM receipt for the total amount received on this STREAM connection, per `connectionId`,\n   * including the additional amount from this packet. Amount must be within the u64 range.\n   */\n  setTotalReceived(totalReceived: LongValue): void\n\n  /** Fulfill the money from this incoming ILP Prepare packet */\n  accept(): IlpFulfill\n\n  /** Temporarily decline the incoming money: inform STREAM sender to backoff in time (T00 Reject: Temporary Internal Error) */\n  temporaryDecline(): IlpReject\n\n  /** Inform the sender to close their connection */\n  finalDecline(): IlpReject\n}\n\n/** Application-layer metadata to encode within the credentials of a new STREAM connection. */\ninterface ConnectionDetails {\n  /**\n   * Arbitrary data to attribute or handle an incoming payment. For example, an identifier to\n   * correlate which user account the payment should be credited to.\n   */\n  paymentTag?: string\n\n  /** Parameters to generate authentic STREAM receipts so a third party may verify incoming payments. */\n  receiptSetup?: {\n    secret: Buffer\n    nonce: Buffer\n  }\n\n  /**\n   * Destination asset details of the recipient's Interledger account, to share with the sender.\n   * Note: required for SPSP, but unnecessary for Open Payments credentials.\n   */\n  asset?: {\n    code: string\n    scale: number\n  }\n}\n\n/**\n * Format of destination ILP address:\n * serverAddress + \".\" + base64url(encrypt(connectionToken, serverSecret))\n * - Encrypted with AES-256-GCM\n * - Random 12-byte IV ensures uniqueness\n *\n * connectionToken schema:\n * ===================================\n *\n * - `flags`         -- UInt8 -- Bit string of enabled features: (1) payment tag, (2) receipt details, (3) asset details\n *\n *   (If payment tag is enabled...)\n * - `paymentTag`    -- VarOctetString\n *\n *   (If receipts are enabled...)\n * - `receiptNonce`  -- 16 raw bytes\n * - `receiptSecret` -- 32 raw bytes\n *\n *   (If asset details are enabled...)\n * - `assetCode`     -- VarOctetString\n * - `assetScale`    -- UInt8\n */\n\n/**\n * Generate and validate STREAM connection credentials so a client may send packets to the STREAM server.\n * This enables an Open Payments or SPSP server to generate new connections separately from the STREAM server\n * and ILP-connected infrastructure, so long as they are configured with the same server secret and ILP address.\n */\nexport class StreamServer {\n  /** Constant to derive key to encrypt connection tokens in the ILP address */\n  private static TOKEN_GENERATION_STRING = Buffer.from('ilp_stream_connection_token')\n\n  /** Constant to derive shared secrets, combined with the connection token */\n  private static SHARED_SECRET_GENERATION_STRING = Buffer.from('ilp_stream_shared_secret')\n\n  /** Constant to derive packet decryption key, combined with the shared secret */\n  private static ENCRYPTION_KEY_STRING = Buffer.from('ilp_stream_encryption')\n\n  /** Constant to derive packet fulfillments, combined with the shared secret */\n  private static FULFILLMENT_GENERATION_STRING = Buffer.from('ilp_stream_fulfillment')\n\n  /** Pre-allocated Buffer to serialize connection tokens (safe since `generateCredentials` is synchronous) */\n  private static TOKEN_GENERATION_BUFFER = Buffer.alloc(767) // Max # of base64 characters in ILP address\n\n  /** Flag bits to flip to determine enabled features */\n  private static TOKEN_FLAGS = {\n    PAYMENT_TAG: 1, // 2^0\n    RECEIPTS: 2, // 2^1\n    ASSET_DETAILS: 4, // 2^2\n  }\n\n  /** Base ILP address of the server accessible over its Interledger network */\n  private serverAddress: IlpAddress\n\n  /** Derived key for generating shared secrets */\n  private sharedSecretKeyGen: Buffer\n\n  /** Derived key for generating connection tokens */\n  private connectionTokenKeyGen: Buffer\n\n  constructor({ serverSecret, serverAddress }: ServerOptions) {\n    if (serverSecret.byteLength !== 32) {\n      throw new Error('Server secret must be 32 bytes')\n    }\n\n    if (!isValidIlpAddress(serverAddress)) {\n      throw new Error('Invalid server base ILP address')\n    }\n\n    this.serverAddress = serverAddress\n    this.sharedSecretKeyGen = hmac(serverSecret, StreamServer.SHARED_SECRET_GENERATION_STRING)\n    this.connectionTokenKeyGen = hmac(serverSecret, StreamServer.TOKEN_GENERATION_STRING)\n  }\n\n  /**\n   * Generate credentials to return to a STREAM client so they may establish a connection to this STREAM server.\n   * Throws if the receipt nonce or secret are invalid lengths, the asset scale was not 0-255,\n   * or that data cannot fit within an ILP address.\n   */\n  generateCredentials(options: ConnectionDetails = {}): StreamCredentials {\n    const { receiptSetup, asset } = options\n\n    if (receiptSetup) {\n      if (receiptSetup.nonce.byteLength !== 16) {\n        throw new Error('Failed to generate credentials: receipt nonce must be 16 bytes')\n      }\n\n      if (receiptSetup.secret.byteLength !== 32) {\n        throw new Error('Failed to generate credentials: receipt secret must be 32 bytes')\n      }\n    }\n\n    if (asset && !isValidAssetScale(asset.scale)) {\n      throw new Error('Failed to generate credentials: invalid asset scale')\n    }\n\n    const paymentTag = options.paymentTag ? Buffer.from(options.paymentTag, 'ascii') : undefined\n\n    const flags =\n      (paymentTag ? StreamServer.TOKEN_FLAGS.PAYMENT_TAG : 0) |\n      (receiptSetup ? StreamServer.TOKEN_FLAGS.RECEIPTS : 0) |\n      (asset ? StreamServer.TOKEN_FLAGS.ASSET_DETAILS : 0)\n\n    const writer = new Writer(StreamServer.TOKEN_GENERATION_BUFFER)\n    writer.writeUInt8(flags)\n\n    if (paymentTag) {\n      writer.writeVarOctetString(paymentTag)\n    }\n\n    if (receiptSetup) {\n      writer.write(receiptSetup.nonce)\n      writer.write(receiptSetup.secret)\n    }\n\n    if (asset) {\n      writer.writeVarOctetString(Buffer.from(asset.code, 'utf8'))\n      writer.writeUInt8(asset.scale)\n    }\n\n    const token = encrypt(this.connectionTokenKeyGen, writer.getBuffer())\n    const sharedSecret = hmac(this.sharedSecretKeyGen, token)\n\n    const destinationAddress = `${this.serverAddress}.${base64url(token)}`\n    if (!isValidIlpAddress(destinationAddress)) {\n      throw new Error(\n        'Failed to generate credentials: too much data to encode within an ILP address'\n      )\n    }\n\n    return {\n      ilpAddress: destinationAddress,\n      sharedSecret,\n    }\n  }\n\n  private extractLocalAddressSegment(destinationAddress: string): string | undefined {\n    const localAddressParts = destinationAddress.slice(this.serverAddress.length + 1).split('.')\n    if (destinationAddress.startsWith(this.serverAddress + '.') && !!localAddressParts[0]) {\n      return localAddressParts[0]\n    }\n  }\n\n  private decryptToken(token: Buffer): ConnectionDetails | undefined {\n    try {\n      const details: ConnectionDetails = {}\n      const decryptedToken = decrypt(this.connectionTokenKeyGen, token)\n\n      const reader = new Reader(decryptedToken)\n      const flags = reader.readUInt8Number()\n\n      const hasPaymentTag = (flags & StreamServer.TOKEN_FLAGS.PAYMENT_TAG) !== 0\n      const hasReceiptDetails = (flags & StreamServer.TOKEN_FLAGS.RECEIPTS) !== 0\n      const hasAssetDetails = (flags & StreamServer.TOKEN_FLAGS.ASSET_DETAILS) !== 0\n\n      if (hasPaymentTag) {\n        details.paymentTag = reader.readVarOctetString().toString('ascii')\n      }\n\n      if (hasReceiptDetails) {\n        details.receiptSetup = {\n          nonce: reader.read(16),\n          secret: reader.read(32),\n        }\n      }\n\n      if (hasAssetDetails) {\n        details.asset = {\n          code: reader.readVarOctetString().toString(),\n          scale: reader.readUInt8Number(),\n        }\n      }\n\n      return details\n    } catch (_) {\n      // No-op: failed decryption or structurally invalid\n    }\n  }\n\n  /**\n   * Extract the `paymentTag` from the given destination ILP address, or return `undefined`\n   * if the connection token is invalid or no payment tag was encoded.\n   */\n  decodePaymentTag(destinationAddress: string): string | void {\n    const token = this.extractLocalAddressSegment(destinationAddress)\n    if (token) {\n      return this.decryptToken(Buffer.from(token, 'base64'))?.paymentTag\n    }\n  }\n\n  /**\n   * Validate and decrypt the destination ILP address of an incoming ILP Prepare:\n   * ensure it's addressed to the server and decode encrypted metadata to attribute and handle the payment.\n   */\n  createReply(prepare: IlpPrepare): IncomingMoney | IlpReply {\n    const connectionId = sha256(Buffer.from(prepare.destination, 'ascii')).toString('hex')\n    const log = createLogger(`ilp-receiver:${connectionId.slice(0, 6)}`)\n    const reply = new ReplyBuilder().setIlpAddress(this.serverAddress)\n\n    // Ensure the packet is addressed to us\n    const localSegment = this.extractLocalAddressSegment(prepare.destination)\n    if (!localSegment) {\n      log.trace('got packet not addressed to the receiver. destination=%s', prepare.destination)\n      return reply.buildReject(IlpError.F02_UNREACHABLE)\n    }\n\n    const token = Buffer.from(localSegment, 'base64')\n    const connectionDetails = this.decryptToken(token)\n    if (!connectionDetails) {\n      log.trace(\n        'invalid connection token: cannot attribute incoming packet. token=%s',\n        localSegment\n      )\n      return reply.buildReject(IlpError.F06_UNEXPECTED_PAYMENT)\n    }\n    const { paymentTag, receiptSetup, asset } = connectionDetails\n\n    log.debug('got incoming Prepare. amount: %s', prepare.amount)\n\n    const sharedSecret = hmac(this.sharedSecretKeyGen, token)\n    const encryptionKey = hmac(sharedSecret, StreamServer.ENCRYPTION_KEY_STRING)\n    let streamRequest: Packet\n    try {\n      streamRequest = Packet._deserializeUnencrypted(decrypt(encryptionKey, prepare.data))\n    } catch (_) {\n      log.trace('rejecting with F06: failed to decrypt STREAM data') // Inauthentic, could be anyone\n      return reply.buildReject(IlpError.F06_UNEXPECTED_PAYMENT)\n    }\n\n    if (+streamRequest.ilpPacketType !== IlpPacketType.Prepare) {\n      log.warn('rejecting with F00: invalid STREAM packet type') // Sender violated protocol, or intermediaries swapped valid STREAM packets\n      return reply.buildReject(IlpError.F00_BAD_REQUEST) // Client should not retry, but don't include STREAM data since the request was inauthentic\n    }\n\n    log.debug(\n      'got authentic STREAM request. sequence: %s, min destination amount: %s',\n      streamRequest.sequence,\n      streamRequest.prepareAmount\n    )\n    log.trace('STREAM request frames: %o', streamRequest.frames)\n\n    reply\n      .setEncryptionKey(encryptionKey)\n      .setSequence(streamRequest.sequence)\n      .setReceivedAmount(prepare.amount)\n\n    const closeFrame = streamRequest.frames.find(\n      (frame): frame is ConnectionCloseFrame => frame.type === FrameType.ConnectionClose\n    )\n    if (closeFrame) {\n      log.trace(\n        'client closed connection, rejecting with F99. code=\"%s\" message=\"%s\"',\n        ErrorCode[closeFrame.errorCode],\n        closeFrame.errorMessage\n      )\n      // Echo connection closes from the client\n      return reply\n        .addFrames(new ConnectionCloseFrame(ErrorCode.NoError, ''))\n        .buildReject(IlpError.F99_APPLICATION_ERROR)\n    }\n\n    const isNewConnection = streamRequest.frames.some(\n      (frame) => frame.type === FrameType.ConnectionNewAddress\n    )\n    if (isNewConnection && asset) {\n      log.trace(\n        'got new client address, replying with asset details: %s %s',\n        asset.code,\n        asset.scale\n      )\n      reply.addFrames(new ConnectionAssetDetailsFrame(asset.code, asset.scale))\n    }\n\n    /**\n     * Why no `StreamMaxMoney` frame in the reply?\n     * - Limits on how much money can be received should probably be negotiated\n     *   at the application layer instead of STREAM. The API consumer can optionally\n     *   limit the amount received by declining incoming money, and by default, STREAM\n     *   senders assume there's no limit on the remote maximum\n     * - `ilp-protocol-stream` sender does not publicly expose the remote amount\n     *   received on each individual stream (it's only tracked for backpressure),\n     *   so it's unnecessary to reply with the total received on a per-stream basis\n     */\n\n    const receivedAmount = Long.fromString(prepare.amount, true)\n    const didReceiveMinimum = receivedAmount.greaterThanOrEqual(streamRequest.prepareAmount)\n    if (!didReceiveMinimum) {\n      return reply.buildReject(IlpError.F99_APPLICATION_ERROR)\n    }\n\n    const fulfillmentKey = hmac(sharedSecret, StreamServer.FULFILLMENT_GENERATION_STRING)\n    const fulfillment = hmac(fulfillmentKey, prepare.data)\n    const isFulfillable = sha256(fulfillment).equals(prepare.executionCondition)\n    if (!isFulfillable) {\n      return reply.buildReject(IlpError.F99_APPLICATION_ERROR)\n    } else if (receivedAmount.isZero()) {\n      /**\n       * `ilp-protocol-stream` as a client sometimes handles replies differently if they're sent back in an\n       *  ILP Fulfill vs an ILP Reject, so 0 amount packets should be fulfilled.\n       *\n       * For example, replying to a `StreamClose` frame with an F99 Reject in Node 10 results in an infinite loop,\n       * since `ilp-protocol-stream` re-queues the frame and tries again. Replying with an ILP Fulfill prevents\n       * this (no money is received since the amount is 0). This issue does not occur in Node 12 (?).\n       *\n       * https://github.com/interledgerjs/ilp-protocol-stream/blob/7ad483f5fd1a1d1e4dc58d7eef6a437594646260/src/connection.ts#L1499-L1505\n       */\n      return reply.buildFulfill(fulfillment)\n    }\n\n    return {\n      connectionId,\n\n      paymentTag,\n\n      setTotalReceived: (totalReceived: LongValue) => {\n        if (receiptSetup) {\n          /**\n           * Even if we receive money over multiple streams with different stream IDs, we only generate\n           * STREAM receipts for streamId=1. There should be no effect for the sender or verifier,\n           * since the total amount credited to this receipt nonce will still be the same.\n           *\n           * Per RFC, client MUST open streams starting with streamId=1.\n           */\n          const receipt = createReceipt({\n            ...receiptSetup,\n            totalReceived,\n            streamId: 1,\n          })\n          reply.addFrames(new StreamReceiptFrame(1, receipt))\n        }\n      },\n\n      accept: () => reply.buildFulfill(fulfillment),\n\n      temporaryDecline: () => reply.buildReject(IlpError.T00_INTERNAL_ERROR),\n\n      finalDecline: () =>\n        reply\n          .addFrames(new ConnectionCloseFrame(ErrorCode.NoError, ''))\n          .buildReject(IlpError.F99_APPLICATION_ERROR),\n    }\n  }\n}\n"]}