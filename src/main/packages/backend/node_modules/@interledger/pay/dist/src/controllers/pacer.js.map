{"version":3,"file":"pacer.js","sourceRoot":"","sources":["../../../src/controllers/pacer.ts"],"names":[],"mappings":"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","sourcesContent":["import { RequestState, StreamController } from '.'\nimport { sleep } from '../utils'\nimport { StreamReply } from '../request'\n\n/**\n * Flow controller to send packets at a consistent cadence\n * and prevent sending more packets than the network can handle\n */\nexport class PacingController implements StreamController {\n  /** Initial number of packets to send in 1 second interval (25ms delay between packets) */\n  private static DEFAULT_PACKETS_PER_SECOND = 40\n\n  /** Always try to send at least 1 packet in 1 second (unless RTT is very high) */\n  private static MIN_PACKETS_PER_SECOND = 1\n\n  /** Maximum number of packets to send in a 1 second interval, after ramp up (5ms delay) */\n  private static MAX_PACKETS_PER_SECOND = 200\n\n  /** Additive increase of packets per second rate on authentic reply */\n  private static PACKETS_PER_SECOND_INCREASE_TERM = 0.5\n\n  /** Multiplicative decrease of packets per second rate on transient error */\n  private static PACKETS_PER_SECOND_DECREASE_FACTOR = 0.5\n\n  /** RTT to use for pacing before an average can be ascertained */\n  private static DEFAULT_ROUND_TRIP_TIME_MS = 200\n\n  /** Weight to compute next RTT average. Halves weight of past round trips every ~5 flights */\n  private static ROUND_TRIP_AVERAGE_WEIGHT = 0.9\n\n  /** Maximum number of packets to have in-flight, yet to receive a Fulfill or Reject */\n  private static MAX_INFLIGHT_PACKETS = 20\n\n  /** UNIX timestamp when most recent packet was sent */\n  private lastPacketSentTime = 0\n\n  /** Exponential weighted moving average of the round trip time */\n  private averageRoundTrip = PacingController.DEFAULT_ROUND_TRIP_TIME_MS\n\n  /** Rate of packets to send per second. This shouldn't ever be 0, but may become a small fraction */\n  private packetsPerSecond = PacingController.DEFAULT_PACKETS_PER_SECOND\n\n  /** Number of in-flight requests */\n  private inFlightCount = 0\n\n  /**\n   * Rate to send packets, in packets / millisecond, using packet rate limit and round trip time.\n   * Corresponds to the ms delay between each packet\n   */\n  getPacketFrequency(): number {\n    const packetsPerSecondDelay = 1000 / this.packetsPerSecond\n    const maxInFlightDelay = this.averageRoundTrip / PacingController.MAX_INFLIGHT_PACKETS\n\n    return Math.max(packetsPerSecondDelay, maxInFlightDelay)\n  }\n\n  /** Earliest UNIX timestamp when the pacer will allow the next packet to be sent */\n  getNextPacketSendTime(): number {\n    const delayDuration = this.getPacketFrequency()\n    return this.lastPacketSentTime + delayDuration\n  }\n\n  buildRequest(): RequestState {\n    const durationUntilNextPacket = this.getNextPacketSendTime() - Date.now()\n    return durationUntilNextPacket > 0\n      ? RequestState.Schedule(sleep(durationUntilNextPacket))\n      : this.inFlightCount >= PacingController.MAX_INFLIGHT_PACKETS\n      ? RequestState.Yield() // Assumes sender will schedule another attempt when in-flight requests complete\n      : RequestState.Ready()\n  }\n\n  applyRequest(): (reply: StreamReply) => void {\n    const sentTime = Date.now()\n    this.lastPacketSentTime = sentTime\n\n    this.inFlightCount++\n\n    return (reply: StreamReply) => {\n      this.inFlightCount--\n\n      // Only update the RTT if we know the request got to the recipient\n      if (reply.isAuthentic()) {\n        const roundTripTime = Math.max(Date.now() - sentTime, 0)\n        this.averageRoundTrip =\n          this.averageRoundTrip * PacingController.ROUND_TRIP_AVERAGE_WEIGHT +\n          roundTripTime * (1 - PacingController.ROUND_TRIP_AVERAGE_WEIGHT)\n      }\n\n      // TODO Add separate liquidity congestion controller/logic, don't backoff in time on T04s\n\n      // If we encounter a temporary error that's not related to liquidity,\n      // exponentially backoff the rate of packet sending\n      if (reply.isReject() && reply.ilpReject.code[0] === 'T') {\n        const reducedRate = Math.max(\n          PacingController.MIN_PACKETS_PER_SECOND,\n          this.packetsPerSecond * PacingController.PACKETS_PER_SECOND_DECREASE_FACTOR // Fractional rates are fine\n        )\n        reply.log.debug(\n          'handling %s. backing off to %s packets / second',\n          reply.ilpReject.code,\n          reducedRate.toFixed(3)\n        )\n        this.packetsPerSecond = reducedRate\n      }\n      // If the packet got through, additive increase of sending rate, up to some maximum\n      else if (reply.isAuthentic()) {\n        this.packetsPerSecond = Math.min(\n          PacingController.MAX_PACKETS_PER_SECOND,\n          this.packetsPerSecond + PacingController.PACKETS_PER_SECOND_INCREASE_TERM\n        )\n      }\n    }\n  }\n}\n"]}