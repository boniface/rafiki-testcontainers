{"version":3,"file":"max-packet.js","sourceRoot":"","sources":["../../../src/controllers/max-packet.ts"],"names":[],"mappings":"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","sourcesContent":["import { Reader } from 'oer-utils'\nimport { StreamController } from './'\nimport { Int, PositiveInt, Ratio } from '../utils'\nimport { Logger } from 'ilp-logger'\nimport { PaymentError } from '..'\nimport { IlpError } from 'ilp-packet'\nimport { StreamReject, StreamReply, StreamRequest } from '../request'\nimport { RateProbe } from '../senders/rate-probe'\n\n/** How the maximum packet amount is known or discovered */\nenum MaxPacketState {\n  /** Initial state before any F08 errors have been encountered */\n  UnknownMax,\n  /** F08 errors included metadata to communicate the precise max packet amount */\n  PreciseMax,\n  /**\n   * F08 errors isolated an upper max packet amount, but didn't communicate it precisely.\n   * Discover the exact max packet amount through probing.\n   */\n  ImpreciseMax,\n}\n\n/** Max packet amount and how it was discovered */\ntype MaxPacketAmount =\n  | {\n      type: MaxPacketState.PreciseMax\n      /** Precise max packet amount communicated from F08 errors */\n      maxPacketAmount: PositiveInt\n    }\n  | {\n      type: MaxPacketState.ImpreciseMax\n      /** Max packet amount is known to be less than this, but isn't known precisely */\n      maxPacketAmount: PositiveInt\n    }\n  | {\n      type: MaxPacketState.UnknownMax\n    }\n\n/** Controller to limit packet amount based on F08 errors */\nexport class MaxPacketAmountController implements StreamController {\n  /** Max packet amount and how it was discovered */\n  private state: MaxPacketAmount\n\n  /**\n   * Greatest amount the recipient acknowledged to have received.\n   * Note: this is always reduced so it's never greater than the max packet amount\n   */\n  private verifiedPathCapacity = Int.ZERO\n\n  constructor(preciseMaxPacketAmount?: PositiveInt) {\n    this.state = preciseMaxPacketAmount\n      ? {\n          type: MaxPacketState.PreciseMax,\n          maxPacketAmount: preciseMaxPacketAmount,\n        }\n      : {\n          type: MaxPacketState.UnknownMax,\n        }\n  }\n\n  /**\n   * Return a limit on the amount of the next packet: the precise max packet amount,\n   * or a probe amount if the precise max packet amount is yet to be discovered.\n   */\n  getNextMaxPacketAmount(): PositiveInt | undefined {\n    switch (this.state.type) {\n      case MaxPacketState.PreciseMax:\n        return this.state.maxPacketAmount\n\n      // Use a binary search to discover the precise max\n      case MaxPacketState.ImpreciseMax:\n        // Always positive:\n        // - If verifiedCapacity=0, maxPacketAmount / 2 must round up to 1\n        // - If verifiedCapacity=maxPacketAmount,\n        //   verifiedCapacity is positive, so adding it will always be positive\n        return this.state.maxPacketAmount\n          .saturatingSubtract(this.verifiedPathCapacity)\n          .divideCeil(Int.TWO)\n          .add(this.verifiedPathCapacity) as PositiveInt\n\n      case MaxPacketState.UnknownMax:\n        return undefined\n    }\n  }\n\n  /** Did we verify the precise max packet amount or a large path capacity? */\n  isProbeComplete(): boolean {\n    const verifiedPreciseMax =\n      this.state.type === MaxPacketState.PreciseMax &&\n      this.verifiedPathCapacity.isEqualTo(this.state.maxPacketAmount)\n    const verifiedLargeCapacity =\n      this.state.type === MaxPacketState.UnknownMax &&\n      this.verifiedPathCapacity.isGreaterThanOrEqualTo(RateProbe.MAX_PROBE_AMOUNT)\n    return verifiedPreciseMax || verifiedLargeCapacity\n  }\n\n  /** Return the current upper bound on the max packet amount */\n  getMaxPacketAmountLimit(): PositiveInt {\n    return this.state.type === MaxPacketState.UnknownMax ? Int.MAX_U64 : this.state.maxPacketAmount\n  }\n\n  applyRequest({ sourceAmount }: StreamRequest) {\n    return (reply: StreamReply): PaymentError | void => {\n      if (reply.isReject() && reply.ilpReject.code === IlpError.F08_AMOUNT_TOO_LARGE) {\n        return this.reduceMaxPacketAmount(reply, sourceAmount)\n      } else if (reply.isAuthentic()) {\n        this.adjustPathCapacity(reply.log, sourceAmount)\n      }\n    }\n  }\n\n  /** Decrease the path max packet amount in response to F08 errors */\n  private reduceMaxPacketAmount(reply: StreamReject, sourceAmount: Int): PaymentError | void {\n    const { log, ilpReject } = reply\n\n    let newMax: Int\n    let isPreciseMax: boolean\n    try {\n      const reader = Reader.from(ilpReject.data)\n      const remoteReceived = Int.from(reader.readUInt64Long())\n      const remoteMaximum = Int.from(reader.readUInt64Long())\n\n      log.debug('handling F08. remote received: %s, remote max: %s', remoteReceived, remoteMaximum)\n\n      // F08 is invalid if they received less than their own maximum!\n      // This check ensures that remoteReceived is always > 0\n      if (!remoteReceived.isGreaterThan(remoteMaximum)) {\n        return\n      }\n\n      // Convert remote max packet amount into source units\n      const exchangeRate = Ratio.of(sourceAmount, remoteReceived)\n      newMax = remoteMaximum.multiplyFloor(exchangeRate) // newMax <= source amount since remoteMaximum / remoteReceived is < 1\n      isPreciseMax = true\n    } catch (_) {\n      // If no metadata was included, the only thing we can infer is that the amount we sent was too high\n      log.debug('handling F08 without metadata. source amount: %s', sourceAmount)\n      newMax = sourceAmount.saturatingSubtract(Int.ONE)\n      isPreciseMax = false\n    }\n\n    // Special case if max packet is 0 or rounds to 0\n    if (!newMax.isPositive()) {\n      log.debug('ending payment: max packet amount is 0, cannot send over path')\n      return PaymentError.ConnectorError\n    }\n\n    if (this.state.type === MaxPacketState.UnknownMax) {\n      log.debug('setting initial max packet amount to %s', newMax)\n    } else if (newMax.isLessThan(this.state.maxPacketAmount)) {\n      log.debug('reducing max packet amount from %s to %s', this.state.maxPacketAmount, newMax)\n    } else {\n      return // Ignore F08s that don't lower the max packet amount\n    }\n\n    this.state = {\n      type: isPreciseMax ? MaxPacketState.PreciseMax : MaxPacketState.ImpreciseMax,\n      maxPacketAmount: newMax,\n    }\n\n    this.adjustPathCapacity(log, this.verifiedPathCapacity)\n  }\n\n  /**\n   * Increase the greatest amount acknowledged by the recipient, which\n   * indicates the path is capable of sending packets of at least that amount\n   */\n  private adjustPathCapacity(log: Logger, ackAmount: Int) {\n    const newPathCapacity = this.verifiedPathCapacity\n      .orGreater(ackAmount)\n      .orLesser(this.getMaxPacketAmountLimit())\n    if (newPathCapacity.isGreaterThan(this.verifiedPathCapacity)) {\n      log.debug(\n        'increasing greatest path packet amount from %s to %s',\n        this.verifiedPathCapacity,\n        newPathCapacity\n      )\n    }\n\n    this.verifiedPathCapacity = newPathCapacity\n\n    if (\n      this.state.type === MaxPacketState.ImpreciseMax &&\n      this.verifiedPathCapacity.isEqualTo(this.state.maxPacketAmount)\n    ) {\n      // Binary search from F08s without metadata is complete: discovered precise max\n      log.debug('discovered precise max packet amount: %s', this.state.maxPacketAmount)\n      this.state = {\n        type: MaxPacketState.PreciseMax,\n        maxPacketAmount: this.state.maxPacketAmount,\n      }\n    }\n  }\n}\n"]}