{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  IlpPrepare,\n  deserializeIlpPrepare,\n  serializeIlpPrepare,\n  IlpFulfill,\n  serializeIlpFulfill,\n  deserializeIlpFulfill,\n} from 'ilp-packet'\nimport { Reader, Writer } from 'oer-utils'\nimport { readUuid, writeUuid } from './uuid'\n\nexport const CCP_CONTROL_DESTINATION = 'peer.route.control'\nexport const CCP_UPDATE_DESTINATION = 'peer.route.update'\nexport const PEER_PROTOCOL_FULFILLMENT = Buffer.alloc(32)\nexport const PEER_PROTOCOL_CONDITION = Buffer.from(\n  'Zmh6rfhivXdsj8GLjp+OIAiXFIVu4jOzkCpZHQ1fKSU=',\n  'base64'\n)\nconst PEER_PROTOCOL_EXPIRY_DURATION = 60000\n\nexport enum Mode {\n  MODE_IDLE = 0,\n  MODE_SYNC = 1,\n}\n\nexport const ModeReverseMap = ['IDLE', 'SYNC']\n\nexport interface CcpRouteControlRequest {\n  mode: Mode.MODE_IDLE | Mode.MODE_SYNC\n  lastKnownRoutingTableId: string\n  lastKnownEpoch: number\n  features: string[]\n}\n\nexport interface CcpRouteControlResponse {\n  // empty\n}\n\n// Well-known route property IDs\nexport enum PropId {}\n\nexport interface CcpRoutePropCommon {\n  isOptional: boolean\n  isTransitive: boolean\n  isPartial: boolean\n}\n\nexport interface CcpRoutePropBuffer extends CcpRoutePropCommon {\n  isUtf8: false\n  id: number\n  value: Buffer\n}\n\nexport interface CcpRoutePropString extends CcpRoutePropCommon {\n  isUtf8: true\n  id: number\n  value: string\n}\n\nexport type CcpRouteProp =\n  // Generic props\n  CcpRoutePropBuffer | CcpRoutePropString\n\nexport interface CcpRoute {\n  prefix: string\n  path: string[]\n  auth: Buffer\n  props: CcpRouteProp[]\n}\n\nexport interface CcpRouteUpdateRequest {\n  routingTableId: string\n  currentEpochIndex: number\n  fromEpochIndex: number\n  toEpochIndex: number\n  holdDownTime: number\n  speaker: string\n  newRoutes: CcpRoute[]\n  withdrawnRoutes: string[]\n}\n\nexport interface CcpRouteUpdateResponse {\n  // empty\n}\n\nconst deserializeCcpRouteControlRequestPayload = (data: Buffer): CcpRouteControlRequest => {\n  const reader = new Reader(data)\n\n  const mode = reader.readUInt8Number()\n\n  const lastKnownRoutingTableId = readUuid(reader)\n\n  const lastKnownEpoch = reader.readUInt32Number()\n\n  const featureCount = reader.readVarUIntNumber()\n  const features = []\n  for (let i = 0; i < featureCount; i++) {\n    features.push(reader.readVarOctetString().toString('utf8'))\n  }\n\n  return {\n    mode,\n    lastKnownRoutingTableId,\n    lastKnownEpoch,\n    features,\n  }\n}\n\nconst extractCcpRouteControlRequest = (packet: IlpPrepare): CcpRouteControlRequest => {\n  if (packet.destination !== CCP_CONTROL_DESTINATION) {\n    throw new TypeError('packet is not a CCP route control request.')\n  }\n\n  if (!PEER_PROTOCOL_CONDITION.equals(packet.executionCondition)) {\n    throw new Error('packet does not contain correct condition for a peer protocol request.')\n  }\n\n  if (Date.now() > Number(packet.expiresAt)) {\n    throw new Error('CCP route control request packet is expired.')\n  }\n\n  return deserializeCcpRouteControlRequestPayload(packet.data)\n}\n\nconst deserializeCcpRouteControlRequest = (request: Buffer): CcpRouteControlRequest => {\n  const packet = deserializeIlpPrepare(request)\n\n  return extractCcpRouteControlRequest(packet)\n}\n\nconst serializeCcpRouteControlRequestPayload = (request: CcpRouteControlRequest): Buffer => {\n  const writer = new Writer()\n\n  writer.writeUInt8(request.mode)\n\n  writeUuid(writer, request.lastKnownRoutingTableId)\n\n  writer.writeUInt32(request.lastKnownEpoch)\n\n  writer.writeVarUInt(request.features.length)\n\n  for (const feature of request.features) {\n    writer.writeVarOctetString(Buffer.from(feature, 'utf8'))\n  }\n\n  return writer.getBuffer()\n}\n\nconst constructCcpRouteControlRequest = (request: CcpRouteControlRequest): IlpPrepare => {\n  return {\n    amount: '0',\n    destination: CCP_CONTROL_DESTINATION,\n    executionCondition: PEER_PROTOCOL_CONDITION,\n    expiresAt: new Date(Date.now() + PEER_PROTOCOL_EXPIRY_DURATION),\n    data: serializeCcpRouteControlRequestPayload(request),\n  }\n}\n\nconst serializeCcpRouteControlRequest = (request: CcpRouteControlRequest): Buffer => {\n  return serializeIlpPrepare(constructCcpRouteControlRequest(request))\n}\n\nconst deserializeCcpRouteUpdateRequestPayload = (payload: Buffer): CcpRouteUpdateRequest => {\n  const reader = new Reader(payload)\n\n  const routingTableId = readUuid(reader)\n  const currentEpochIndex = reader.readUInt32Number()\n  const fromEpochIndex = reader.readUInt32Number()\n  const toEpochIndex = reader.readUInt32Number()\n  const holdDownTime = reader.readUInt32Number()\n  const speaker = reader.readVarOctetString().toString('ascii')\n\n  const newRoutesCount = reader.readVarUIntNumber()\n  const newRoutes = []\n  for (let i = 0; i < newRoutesCount; i++) {\n    const prefix = reader.readVarOctetString().toString('ascii')\n\n    const pathLength = reader.readVarUIntNumber()\n    const path = []\n    for (let i = 0; i < pathLength; i++) {\n      path.push(reader.readVarOctetString().toString('ascii'))\n    }\n\n    const auth = reader.read(32)\n\n    const propCount = reader.readVarUIntNumber()\n    const props: CcpRouteProp[] = []\n    for (let i = 0; i < propCount; i++) {\n      const meta = reader.readUInt8Number()\n      const isOptional = Boolean(meta & 0x80)\n      const isTransitive = Boolean(meta & 0x40)\n      const isPartial = Boolean(meta & 0x20)\n      const isUtf8 = Boolean(meta & 0x10)\n\n      const id = reader.readUInt16Number()\n      const value = reader.readVarOctetString()\n\n      const incompleteProp = {\n        isOptional,\n        isTransitive,\n        isPartial,\n        id,\n      }\n\n      if (isUtf8) {\n        props.push({\n          ...incompleteProp,\n          isUtf8: true,\n          value: value.toString('utf8'),\n        })\n      } else {\n        props.push({\n          ...incompleteProp,\n          isUtf8: false,\n          value: value,\n        })\n      }\n    }\n\n    newRoutes.push({\n      prefix,\n      path,\n      auth,\n      props,\n    })\n  }\n\n  const withdrawnRoutesCount = reader.readVarUIntNumber()\n  const withdrawnRoutes = []\n  for (let i = 0; i < withdrawnRoutesCount; i++) {\n    withdrawnRoutes.push(reader.readVarOctetString().toString('utf8'))\n  }\n\n  return {\n    routingTableId,\n    currentEpochIndex,\n    fromEpochIndex,\n    toEpochIndex,\n    holdDownTime,\n    speaker,\n    newRoutes,\n    withdrawnRoutes,\n  }\n}\n\nconst extractCcpRouteUpdateRequest = (packet: IlpPrepare): CcpRouteUpdateRequest => {\n  if (packet.destination !== CCP_UPDATE_DESTINATION) {\n    throw new TypeError('packet is not a CCP route update request.')\n  }\n\n  if (!PEER_PROTOCOL_CONDITION.equals(packet.executionCondition)) {\n    throw new Error('packet does not contain correct condition for a peer protocol request.')\n  }\n\n  if (Date.now() > Number(packet.expiresAt)) {\n    throw new Error('CCP route update request packet is expired.')\n  }\n\n  return deserializeCcpRouteUpdateRequestPayload(packet.data)\n}\n\nconst deserializeCcpRouteUpdateRequest = (request: Buffer): CcpRouteUpdateRequest => {\n  const packet = deserializeIlpPrepare(request)\n\n  return extractCcpRouteUpdateRequest(packet)\n}\n\nconst serializeCcpRouteUpdateRequestPayload = (request: CcpRouteUpdateRequest): Buffer => {\n  const writer = new Writer()\n\n  writeUuid(writer, request.routingTableId)\n\n  writer.writeUInt32(request.currentEpochIndex)\n  writer.writeUInt32(request.fromEpochIndex)\n  writer.writeUInt32(request.toEpochIndex)\n\n  writer.writeUInt32(request.holdDownTime)\n\n  writer.writeVarOctetString(Buffer.from(request.speaker, 'ascii'))\n\n  writer.writeVarUInt(request.newRoutes.length)\n  for (const route of request.newRoutes) {\n    writer.writeVarOctetString(Buffer.from(route.prefix, 'ascii'))\n\n    writer.writeVarUInt(route.path.length)\n    for (const hop of route.path) {\n      writer.writeVarOctetString(Buffer.from(hop, 'ascii'))\n    }\n\n    if (route.auth.length !== 32) {\n      throw new Error('route auth must be 32 bytes. prefix=' + route.prefix)\n    }\n    writer.write(route.auth)\n\n    writer.writeVarUInt(route.props.length)\n    for (const prop of route.props) {\n      let meta = 0\n\n      meta |= prop.isOptional ? 0x80 : 0\n\n      if (prop.isOptional) {\n        meta |= prop.isTransitive ? 0x40 : 0\n\n        if (prop.isTransitive) {\n          meta |= prop.isPartial ? 0x20 : 0\n        }\n      } else {\n        // Transitive bit must be set for well-known properties\n        meta |= 0x40\n      }\n\n      meta |= prop.isUtf8 ? 0x10 : 0\n\n      writer.writeUInt8(meta)\n\n      writer.writeUInt16(prop.id)\n\n      writer.writeVarOctetString(prop.isUtf8 ? Buffer.from(prop.value, 'utf8') : prop.value)\n    }\n  }\n\n  writer.writeVarUInt(request.withdrawnRoutes.length)\n  for (const route of request.withdrawnRoutes) {\n    writer.writeVarOctetString(Buffer.from(route, 'ascii'))\n  }\n\n  return writer.getBuffer()\n}\n\nconst constructCcpRouteUpdateRequest = (request: CcpRouteUpdateRequest): IlpPrepare => {\n  return {\n    amount: '0',\n    destination: CCP_UPDATE_DESTINATION,\n    executionCondition: PEER_PROTOCOL_CONDITION,\n    expiresAt: new Date(Date.now() + PEER_PROTOCOL_EXPIRY_DURATION),\n    data: serializeCcpRouteUpdateRequestPayload(request),\n  }\n}\n\nconst serializeCcpRouteUpdateRequest = (request: CcpRouteUpdateRequest): Buffer => {\n  return serializeIlpPrepare(constructCcpRouteUpdateRequest(request))\n}\n\nconst deserializeCcpResponse = (response: Buffer): void => {\n  const { fulfillment } = deserializeIlpFulfill(response)\n\n  if (!PEER_PROTOCOL_FULFILLMENT.equals(fulfillment)) {\n    throw new Error('CCP response does not contain the expected fulfillment.')\n  }\n}\n\nconst constructCcpResponse = (): IlpFulfill => {\n  return {\n    fulfillment: PEER_PROTOCOL_FULFILLMENT,\n    data: Buffer.alloc(0),\n  }\n}\n\nconst serializeCcpResponse = (): Buffer => {\n  return serializeIlpFulfill(constructCcpResponse())\n}\n\nexport {\n  deserializeCcpRouteControlRequestPayload,\n  extractCcpRouteControlRequest,\n  deserializeCcpRouteControlRequest,\n  serializeCcpRouteControlRequestPayload,\n  constructCcpRouteControlRequest,\n  serializeCcpRouteControlRequest,\n  deserializeCcpRouteUpdateRequestPayload,\n  extractCcpRouteUpdateRequest,\n  deserializeCcpRouteUpdateRequest,\n  serializeCcpRouteUpdateRequestPayload,\n  constructCcpRouteUpdateRequest,\n  serializeCcpRouteUpdateRequest,\n  deserializeCcpResponse,\n  constructCcpResponse,\n  serializeCcpResponse,\n}\n"]}