"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StreamSender = void 0;
const controllers_1 = require("@interledger/pay/dist/src/controllers");
const request_1 = require("@interledger/pay/dist/src/request");
const __1 = require("@interledger/pay");
const ilp_logger_1 = __importDefault(require("ilp-logger"));
const utils_1 = require("@interledger/pay/dist/src/utils");
class StreamSender {
    constructor(plugin, destinationDetails) {
        this.requestScheduler = new Scheduler();
        this.replyScheduler = new Scheduler();
        const { destinationAddress, sharedSecret } = destinationDetails;
        const connectionId = (0, utils_1.sha256)(Buffer.from(destinationAddress)).toString('hex').slice(0, 6);
        this.log = (0, ilp_logger_1.default)(`ilp-pay:${connectionId}`);
        this.sendRequest = (0, request_1.generateKeys)(plugin, sharedSecret);
    }
    trySending() {
        const request = new request_1.RequestBuilder({ log: this.log });
        const requestState = [...this.controllers.values()].reduce((state, controller) => { var _a, _b; return state.type === controllers_1.SendStateType.Ready ? (_b = (_a = controller.buildRequest) === null || _a === void 0 ? void 0 : _a.call(controller, request)) !== null && _b !== void 0 ? _b : state : state; }, controllers_1.RequestState.Ready());
        if (requestState.type !== controllers_1.SendStateType.Ready) {
            return requestState;
        }
        const state = this.nextState(request);
        if (state.type !== controllers_1.SendStateType.Send) {
            return state;
        }
        const replyHandlers = this.controllers.map((c) => { var _a; return (_a = c.applyRequest) === null || _a === void 0 ? void 0 : _a.call(c, request); });
        const task = this.sendRequest(request).then((reply) => () => {
            const error = replyHandlers.map((apply) => apply === null || apply === void 0 ? void 0 : apply(reply)).find(__1.isPaymentError);
            const newState = state.applyReply(reply);
            return error ? controllers_1.SendState.Error(error) : newState;
        });
        this.replyScheduler.queue(task);
        return controllers_1.SendState.Schedule();
    }
    async start() {
        this.requestScheduler.queue(Promise.resolve(this.trySending.bind(this)));
        for (;;) {
            const applyEffects = await Promise.race([
                this.replyScheduler.next(),
                this.requestScheduler.next(),
            ]);
            const state = applyEffects();
            switch (state.type) {
                case controllers_1.SendStateType.Done:
                case controllers_1.SendStateType.Error:
                    await this.replyScheduler.complete();
                    return state.value;
                case controllers_1.SendStateType.Schedule:
                    this.requestScheduler.queue(state.delay.then(() => this.trySending.bind(this)));
            }
        }
    }
}
exports.StreamSender = StreamSender;
class Scheduler {
    constructor() {
        this.pendingTasks = new Set();
        this.nextTick = new PromiseResolver();
    }
    next() {
        this.nextTick = new PromiseResolver();
        this.pendingTasks.forEach((task) => {
            this.resolveTick(task);
        });
        return this.nextTick.promise;
    }
    async complete() {
        return Promise.all([...this.pendingTasks].map((promise) => promise.then((run) => run())));
    }
    queue(task) {
        this.pendingTasks.add(task);
        this.resolveTick(task);
    }
    async resolveTick(task) {
        const run = await task;
        this.nextTick.resolve(((...args) => {
            this.pendingTasks.delete(task);
            return run(...args);
        }));
    }
}
class PromiseResolver {
    constructor() {
        this.promise = new Promise((resolve, reject) => {
            this.resolve = resolve;
            this.reject = reject;
        });
    }
}
//# sourceMappingURL=index.js.map