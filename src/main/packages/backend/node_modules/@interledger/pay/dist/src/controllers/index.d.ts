import { PaymentError } from '@interledger/pay';
import { StreamRequest, StreamReply, RequestBuilder } from '@interledger/pay/dist/src/request';
export interface StreamController {
    buildRequest?(request: RequestBuilder): RequestState;
    applyRequest?(request: StreamRequest): ((reply: StreamReply) => PaymentError | void) | undefined;
}
export declare enum SendStateType {
    Done = 0,
    Error = 1,
    Schedule = 2,
    Yield = 3,
    Ready = 4,
    Send = 5
}
export declare type RequestState = Error | Schedule | Yield | Ready;
export declare type SendState<T> = Error | Schedule | Yield | Send<T> | Done<T>;
declare type Error = {
    type: SendStateType.Error;
    value: PaymentError;
};
declare const Error: (error: PaymentError) => Error;
declare type Schedule = {
    type: SendStateType.Schedule;
    delay: Promise<any>;
};
declare const Schedule: (delay?: Promise<any> | undefined) => Schedule;
declare type Yield = {
    type: SendStateType.Yield;
};
declare const Yield: () => Yield;
declare type Done<T> = {
    type: SendStateType.Done;
    value: T;
};
declare const Done: <T>(value: T) => Done<T>;
declare type Ready = {
    type: SendStateType.Ready;
};
declare const Ready: () => Ready;
declare type Send<T> = {
    type: SendStateType.Send;
    applyReply: (reply: StreamReply) => Done<T> | Schedule | Yield | Error;
};
declare const Send: <T>(applyReply: (reply: StreamReply) => Error | Schedule | Yield | Done<T>) => Send<T>;
export declare const RequestState: {
    Ready: () => Ready;
    Error: (error: PaymentError) => Error;
    Schedule: (delay?: Promise<any> | undefined) => Schedule;
    Yield: () => Yield;
};
export declare const SendState: {
    Done: <T>(value: T) => Done<T>;
    Error: (error: PaymentError) => Error;
    Schedule: (delay?: Promise<any> | undefined) => Schedule;
    Yield: () => Yield;
    Send: <T_1>(applyReply: (reply: StreamReply) => Error | Schedule | Yield | Done<T_1>) => Send<T_1>;
};
export {};
