"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StreamReject = exports.StreamFulfill = exports.RequestBuilder = exports.generateKeys = void 0;
const ilp_logger_1 = require("ilp-logger");
const ilp_packet_1 = require("ilp-packet");
const crypto_1 = require("crypto");
const packet_1 = require("ilp-protocol-stream/dist/src/packet");
const utils_1 = require("@interledger/pay/dist/src/utils");
const generateKeys = (plugin, sharedSecret) => {
    const encryptionKey = (0, utils_1.generateEncryptionKey)(sharedSecret);
    const fulfillmentKey = (0, utils_1.generateFulfillmentKey)(sharedSecret);
    return async (request) => {
        const { sequence, sourceAmount, destinationAddress, minDestinationAmount, frames, isFulfillable, expiresAt, log, } = request;
        const streamRequest = new packet_1.Packet(sequence, ilp_packet_1.IlpPacketType.Prepare.valueOf(), minDestinationAmount.toLong(), frames);
        const data = await streamRequest.serializeAndEncrypt(encryptionKey);
        let executionCondition;
        let fulfillment;
        if (isFulfillable) {
            fulfillment = (0, utils_1.hmac)(fulfillmentKey, data);
            executionCondition = (0, utils_1.sha256)(fulfillment);
            log.debug('sending Prepare. amount=%s minDestinationAmount=%s frames=[%s]', sourceAmount, minDestinationAmount, frames.map((f) => packet_1.FrameType[f.type]).join());
        }
        else {
            executionCondition = (0, crypto_1.randomBytes)(32);
            log.debug('sending unfulfillable Prepare. amount=%s frames=[%s]', sourceAmount, frames.map((f) => packet_1.FrameType[f.type]).join());
        }
        log.trace('loading Prepare with frames: %o', frames);
        const preparePacket = (0, ilp_packet_1.serializeIlpPrepare)({
            destination: destinationAddress,
            amount: sourceAmount.toString(),
            executionCondition,
            expiresAt,
            data,
        });
        const pendingReply = plugin
            .sendData(preparePacket)
            .then((data) => {
            try {
                return (0, ilp_packet_1.deserializeIlpReply)(data);
            }
            catch (_) {
                return createReject(ilp_packet_1.IlpError.F01_INVALID_PACKET);
            }
        })
            .catch((err) => {
            log.error('failed to send Prepare:', err);
            return createReject(ilp_packet_1.IlpError.T00_INTERNAL_ERROR);
        })
            .then((ilpReply) => {
            if (!(0, ilp_packet_1.isFulfill)(ilpReply) || !fulfillment || ilpReply.fulfillment.equals(fulfillment)) {
                return ilpReply;
            }
            log.error('got invalid fulfillment: %h. expected: %h, condition: %h', ilpReply.fulfillment, fulfillment, executionCondition);
            return createReject(ilp_packet_1.IlpError.F05_WRONG_CONDITION);
        });
        const timeoutDuration = expiresAt.getTime() - Date.now();
        const ilpReply = await (0, utils_1.timeout)(timeoutDuration, pendingReply).catch(() => {
            log.error('request timed out.');
            return createReject(ilp_packet_1.IlpError.R00_TRANSFER_TIMED_OUT);
        });
        const streamReply = await packet_1.Packet.decryptAndDeserialize(encryptionKey, ilpReply.data).catch(() => undefined);
        if ((0, ilp_packet_1.isFulfill)(ilpReply)) {
            log.debug('got Fulfill. sentAmount=%s', sourceAmount);
        }
        else if ((0, ilp_packet_1.isReject)(ilpReply)) {
            log.debug('got %s Reject: %s', ilpReply.code, ILP_ERROR_CODES[ilpReply.code]);
            if (ilpReply.message.length > 0 || ilpReply.triggeredBy.length > 0) {
                log.trace('Reject message="%s" triggeredBy=%s', ilpReply.message, ilpReply.triggeredBy);
            }
        }
        else {
            throw new Error('ILP response is neither fulfillment nor rejection');
        }
        let responseFrames;
        let destinationAmount;
        if (streamReply) {
            if (streamReply.sequence.notEquals(sequence)) {
                log.error('discarding STREAM reply: received invalid sequence %s', streamReply.sequence);
            }
            else if (+streamReply.ilpPacketType === ilp_packet_1.IlpPacketType.Reject && (0, ilp_packet_1.isFulfill)(ilpReply)) {
                log.error('discarding STREAM reply: received Fulfill, but recipient claims they sent a Reject');
            }
            else {
                responseFrames = streamReply.frames;
                destinationAmount = utils_1.Int.from(streamReply.prepareAmount);
                log.debug('got authentic STREAM reply. receivedAmount=%s frames=[%s]', destinationAmount, responseFrames.map((f) => packet_1.FrameType[f.type]).join());
                log.trace('STREAM reply frames: %o', responseFrames);
            }
        }
        else if (((0, ilp_packet_1.isFulfill)(ilpReply) || ilpReply.code !== ilp_packet_1.IlpError.F08_AMOUNT_TOO_LARGE) &&
            ilpReply.data.byteLength > 0) {
            log.warn('data in reply unexpectedly failed decryption.');
        }
        return (0, ilp_packet_1.isFulfill)(ilpReply)
            ? new StreamFulfill(log, responseFrames, destinationAmount)
            : new StreamReject(log, ilpReply, responseFrames, destinationAmount);
    };
};
exports.generateKeys = generateKeys;
const ILP_ERROR_CODES = {
    F00: 'bad request',
    F01: 'invalid packet',
    F02: 'unreachable',
    F03: 'invalid amount',
    F04: 'insufficient destination amount',
    F05: 'wrong condition',
    F06: 'unexpected payment',
    F07: 'cannot receive',
    F08: 'amount too large',
    F99: 'application error',
    T00: 'internal error',
    T01: 'peer unreachable',
    T02: 'peer busy',
    T03: 'connector busy',
    T04: 'insufficient liquidity',
    T05: 'rate limited',
    T99: 'application error',
    R00: 'transfer timed out',
    R01: 'insufficient source amount',
    R02: 'insufficient timeout',
    R99: 'application error',
};
const createReject = (code) => ({
    code,
    message: '',
    triggeredBy: '',
    data: Buffer.alloc(0),
});
class RequestBuilder {
    constructor(request) {
        this.request = {
            destinationAddress: 'private.example',
            expiresAt: new Date(),
            sequence: 0,
            sourceAmount: utils_1.Int.ZERO,
            minDestinationAmount: utils_1.Int.ZERO,
            frames: [],
            isFulfillable: false,
            log: new ilp_logger_1.Logger('ilp-pay'),
            ...request,
        };
    }
    get destinationAddress() {
        return this.request.destinationAddress;
    }
    get expiresAt() {
        return this.request.expiresAt;
    }
    get sequence() {
        return this.request.sequence;
    }
    get sourceAmount() {
        return this.request.sourceAmount;
    }
    get minDestinationAmount() {
        return this.request.minDestinationAmount;
    }
    get frames() {
        return this.request.frames;
    }
    get isFulfillable() {
        return this.request.isFulfillable;
    }
    get log() {
        return this.request.log;
    }
    setDestinationAddress(address) {
        this.request.destinationAddress = address;
        return this;
    }
    setExpiry(expiresAt) {
        this.request.expiresAt = expiresAt;
        return this;
    }
    setSequence(sequence) {
        this.request.sequence = sequence;
        this.request.log = this.request.log.extend(sequence.toString());
        return this;
    }
    setSourceAmount(sourceAmount) {
        this.request.sourceAmount = sourceAmount;
        return this;
    }
    setMinDestinationAmount(minDestinationAmount) {
        this.request.minDestinationAmount = minDestinationAmount;
        return this;
    }
    addFrames(...frames) {
        this.request.frames = [...this.request.frames, ...frames];
        return this;
    }
    enableFulfillment() {
        this.request.isFulfillable = true;
        return this;
    }
    build() {
        return { ...this.request };
    }
}
exports.RequestBuilder = RequestBuilder;
class StreamFulfill {
    constructor(log, frames, destinationAmount) {
        this.log = log;
        this.frames = frames;
        this.destinationAmount = destinationAmount;
    }
    isAuthentic() {
        return true;
    }
    isReject() {
        return false;
    }
    isFulfill() {
        return true;
    }
}
exports.StreamFulfill = StreamFulfill;
class StreamReject {
    constructor(log, ilpReject, frames, destinationAmount) {
        this.log = log;
        this.ilpReject = ilpReject;
        this.frames = frames;
        this.destinationAmount = destinationAmount;
    }
    isAuthentic() {
        return !!this.frames && !!this.destinationAmount;
    }
    isReject() {
        return true;
    }
    isFulfill() {
        return false;
    }
}
exports.StreamReject = StreamReject;
//# sourceMappingURL=request.js.map