"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.closeConnection = exports.pay = exports.startQuote = exports.setupPayment = exports.isPaymentError = exports.PaymentError = exports.PaymentType = exports.Counter = exports.Ratio = exports.Int = exports.AccountUrl = void 0;
const asset_details_1 = require("@interledger/pay/dist/src/controllers/asset-details");
const sequence_1 = require("@interledger/pay/dist/src/controllers/sequence");
Object.defineProperty(exports, "Counter", { enumerable: true, get: function () { return sequence_1.Counter; } });
const open_payments_1 = require("@interledger/pay/dist/src/open-payments");
const asset_probe_1 = require("@interledger/pay/dist/src/senders/asset-probe");
const connection_closer_1 = require("@interledger/pay/dist/src/senders/connection-closer");
const payment_1 = require("@interledger/pay/dist/src/senders/payment");
Object.defineProperty(exports, "PaymentType", { enumerable: true, get: function () { return payment_1.PaymentType; } });
const rate_probe_1 = require("@interledger/pay/dist/src/senders/rate-probe");
const utils_1 = require("@interledger/pay/dist/src/utils");
Object.defineProperty(exports, "Int", { enumerable: true, get: function () { return utils_1.Int; } });
Object.defineProperty(exports, "Ratio", { enumerable: true, get: function () { return utils_1.Ratio; } });
var payment_pointer_1 = require("@interledger/pay/dist/src/payment-pointer");
Object.defineProperty(exports, "AccountUrl", { enumerable: true, get: function () { return payment_pointer_1.AccountUrl; } });
var PaymentError;
(function (PaymentError) {
    PaymentError["InvalidPaymentPointer"] = "InvalidPaymentPointer";
    PaymentError["InvalidCredentials"] = "InvalidCredentials";
    PaymentError["InvalidSlippage"] = "InvalidSlippage";
    PaymentError["UnknownSourceAsset"] = "UnknownSourceAsset";
    PaymentError["UnknownPaymentTarget"] = "UnknownPaymentTarget";
    PaymentError["InvalidSourceAmount"] = "InvalidSourceAmount";
    PaymentError["InvalidDestinationAmount"] = "InvalidDestinationAmount";
    PaymentError["UnenforceableDelivery"] = "UnenforceableDelivery";
    PaymentError["InvalidQuote"] = "InvalidQuote";
    PaymentError["InvalidDestination"] = "InvalidDestination";
    PaymentError["QueryFailed"] = "QueryFailed";
    PaymentError["IncomingPaymentCompleted"] = "IncomingPaymentCompleted";
    PaymentError["IncomingPaymentExpired"] = "IncomingPaymentExpired";
    PaymentError["ConnectorError"] = "ConnectorError";
    PaymentError["EstablishmentFailed"] = "EstablishmentFailed";
    PaymentError["UnknownDestinationAsset"] = "UnknownDestinationAsset";
    PaymentError["DestinationAssetConflict"] = "DestinationAssetConflict";
    PaymentError["ExternalRateUnavailable"] = "ExternalRateUnavailable";
    PaymentError["RateProbeFailed"] = "RateProbeFailed";
    PaymentError["InsufficientExchangeRate"] = "InsufficientExchangeRate";
    PaymentError["IdleTimeout"] = "IdleTimeout";
    PaymentError["ClosedByReceiver"] = "ClosedByReceiver";
    PaymentError["IncompatibleReceiveMax"] = "IncompatibleReceiveMax";
    PaymentError["ReceiverProtocolViolation"] = "ReceiverProtocolViolation";
    PaymentError["MaxSafeEncryptionLimit"] = "MaxSafeEncryptionLimit";
})(PaymentError = exports.PaymentError || (exports.PaymentError = {}));
const isPaymentError = (o) => Object.values(PaymentError).includes(o);
exports.isPaymentError = isPaymentError;
const setupPayment = async (options) => {
    const destinationDetailsOrError = await (0, open_payments_1.fetchPaymentDetails)(options);
    if ((0, exports.isPaymentError)(destinationDetailsOrError)) {
        throw destinationDetailsOrError;
    }
    const destinationDetails = destinationDetailsOrError;
    const requestCounter = sequence_1.Counter.from(0);
    const assetOrError = await new asset_probe_1.AssetProbe(options.plugin, destinationDetails, requestCounter).start();
    if ((0, exports.isPaymentError)(assetOrError)) {
        throw assetOrError;
    }
    const destinationAsset = assetOrError;
    return {
        ...destinationDetails,
        destinationAsset,
        requestCounter,
    };
};
exports.setupPayment = setupPayment;
const startQuote = async (options) => {
    var _a, _b, _c;
    const rateProbe = new rate_probe_1.RateProbe(options);
    const { log } = rateProbe;
    const { destinationPaymentDetails, destinationAsset } = options.destination;
    if (destinationPaymentDetails) {
        if (destinationPaymentDetails.completed) {
            log.debug('quote failed: Incoming Payment is already completed.');
            throw PaymentError.IncomingPaymentCompleted;
        }
        if (destinationPaymentDetails.expiresAt && destinationPaymentDetails.expiresAt <= Date.now()) {
            log.debug('quote failed: Incoming Payment is expired.');
            throw PaymentError.IncomingPaymentExpired;
        }
    }
    let target;
    if (destinationPaymentDetails &&
        typeof destinationPaymentDetails.incomingAmount !== 'undefined') {
        const remainingToDeliver = utils_1.Int.from(destinationPaymentDetails.incomingAmount.value -
            destinationPaymentDetails.receivedAmount.value);
        if (!remainingToDeliver || !remainingToDeliver.isPositive()) {
            log.debug('quote failed: Incoming Payment was already paid. incomingAmount=%s receivedAmount=%s', destinationPaymentDetails.incomingAmount, destinationPaymentDetails.receivedAmount);
            throw PaymentError.IncomingPaymentCompleted;
        }
        target = {
            type: payment_1.PaymentType.FixedDelivery,
            amount: remainingToDeliver,
        };
    }
    else if (typeof options.amountToDeliver !== 'undefined') {
        const amountToDeliver = utils_1.Int.from(options.amountToDeliver);
        if (!amountToDeliver || !amountToDeliver.isPositive()) {
            log.debug('invalid config: amount to deliver is not a positive integer');
            throw PaymentError.InvalidDestinationAmount;
        }
        target = {
            type: payment_1.PaymentType.FixedDelivery,
            amount: amountToDeliver,
        };
    }
    else if (typeof options.amountToSend !== 'undefined') {
        const amountToSend = utils_1.Int.from(options.amountToSend);
        if (!amountToSend || !amountToSend.isPositive()) {
            log.debug('invalid config: amount to send is not a positive integer');
            throw PaymentError.InvalidSourceAmount;
        }
        target = {
            type: payment_1.PaymentType.FixedSend,
            amount: amountToSend,
        };
    }
    else {
        log.debug('invalid config: no Incoming Payment with existing incomingAmount, amount to send, or amount to deliver was provided');
        throw PaymentError.UnknownPaymentTarget;
    }
    const slippage = (_a = options.slippage) !== null && _a !== void 0 ? _a : 0.01;
    if (!(0, utils_1.isNonNegativeRational)(slippage) || slippage > 1) {
        log.debug('invalid config: slippage is not a number between 0 and 1');
        throw PaymentError.InvalidSlippage;
    }
    let externalRate;
    if (slippage === 1) {
        externalRate = 0;
    }
    else {
        const { sourceAsset } = options;
        if (!(0, asset_details_1.isValidAssetDetails)(sourceAsset)) {
            log.debug('invalid config: no source asset details were provided');
            throw PaymentError.UnknownSourceAsset;
        }
        if (sourceAsset.code === destinationAsset.code) {
            externalRate = 1;
        }
        else {
            const sourcePrice = (_b = options.prices) === null || _b === void 0 ? void 0 : _b[sourceAsset.code];
            const destinationPrice = (_c = options.prices) === null || _c === void 0 ? void 0 : _c[destinationAsset.code];
            if (!(0, utils_1.isNonNegativeRational)(sourcePrice) ||
                !(0, utils_1.isNonNegativeRational)(destinationPrice) ||
                destinationPrice === 0) {
                log.debug('quote failed: no external rate available from %s to %s', sourceAsset.code, destinationAsset.code);
                throw PaymentError.ExternalRateUnavailable;
            }
            externalRate = sourcePrice / destinationPrice;
        }
        externalRate =
            externalRate *
                (1 - slippage) *
                10 ** (destinationAsset.scale - sourceAsset.scale);
    }
    const minExchangeRate = utils_1.Ratio.from(externalRate);
    log.debug('calculated min exchange rate of %s', minExchangeRate);
    log.debug('starting quote.');
    const rateProbeResult = await rateProbe.start();
    if ((0, exports.isPaymentError)(rateProbeResult)) {
        throw rateProbeResult;
    }
    log.debug('quote complete.');
    const { lowEstimatedExchangeRate, highEstimatedExchangeRate, maxPacketAmount } = rateProbeResult;
    if (!lowEstimatedExchangeRate.isGreaterThanOrEqualTo(minExchangeRate)) {
        log.debug('quote failed: probed exchange rate of %s does not exceed minimum of %s', lowEstimatedExchangeRate, minExchangeRate);
        throw PaymentError.InsufficientExchangeRate;
    }
    let maxSourceAmount;
    let minDeliveryAmount;
    if (target.type === payment_1.PaymentType.FixedSend) {
        maxSourceAmount = target.amount;
        minDeliveryAmount = target.amount.saturatingSubtract(utils_1.Int.ONE).multiplyCeil(minExchangeRate);
    }
    else if (!minExchangeRate.isPositive()) {
        log.debug('quote failed: unenforceable payment delivery. min exchange rate is 0');
        throw PaymentError.UnenforceableDelivery;
    }
    else {
        maxSourceAmount = target.amount.multiplyFloor(minExchangeRate.reciprocal()).add(utils_1.Int.ONE);
        minDeliveryAmount = target.amount;
    }
    return {
        paymentType: target.type,
        lowEstimatedExchangeRate,
        highEstimatedExchangeRate,
        minExchangeRate,
        maxPacketAmount: maxPacketAmount.value,
        maxSourceAmount: maxSourceAmount.value,
        minDeliveryAmount: minDeliveryAmount.value,
    };
};
exports.startQuote = startQuote;
const pay = async (options) => {
    const maxSourceAmount = utils_1.Int.from(options.quote.maxSourceAmount);
    const minDeliveryAmount = utils_1.Int.from(options.quote.minDeliveryAmount);
    const maxPacketAmount = utils_1.Int.from(options.quote.maxPacketAmount);
    if (!maxSourceAmount || !maxSourceAmount.isPositive())
        throw PaymentError.InvalidQuote;
    if (!minDeliveryAmount)
        throw PaymentError.InvalidQuote;
    if (!maxPacketAmount || !maxPacketAmount.isPositive())
        throw PaymentError.InvalidQuote;
    const sender = new payment_1.PaymentSender({
        ...options,
        quote: {
            ...options.quote,
            maxSourceAmount,
            minDeliveryAmount,
            maxPacketAmount,
        },
    });
    const error = await sender.start();
    return {
        ...((0, exports.isPaymentError)(error) && { error }),
        ...sender.getProgress(),
    };
};
exports.pay = pay;
const closeConnection = async (plugin, destination) => {
    await new connection_closer_1.ConnectionCloser(plugin, destination).start();
};
exports.closeConnection = closeConnection;
//# sourceMappingURL=index.js.map