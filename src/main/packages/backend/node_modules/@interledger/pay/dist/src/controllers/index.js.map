{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../src/controllers/index.ts"],"names":[],"mappings":";;;AAuCA,IAAY,aAaX;AAbD,WAAY,aAAa;IAEvB,iDAAI,CAAA;IAEJ,mDAAK,CAAA;IAEL,yDAAQ,CAAA;IAER,mDAAK,CAAA;IAEL,mDAAK,CAAA;IAEL,iDAAI,CAAA;AACN,CAAC,EAbW,aAAa,GAAb,qBAAa,KAAb,qBAAa,QAaxB;AAcD,MAAM,KAAK,GAAG,CAAC,KAAmB,EAAS,EAAE,CAAC,CAAC;IAC7C,IAAI,EAAE,aAAa,CAAC,KAAK;IACzB,KAAK,EAAE,KAAK;CACb,CAAC,CAAA;AAWF,MAAM,QAAQ,GAAG,CAAC,KAAoB,EAAY,EAAE,CAAC,CAAC;IACpD,IAAI,EAAE,aAAa,CAAC,QAAQ;IAC5B,KAAK,EAAE,KAAK,aAAL,KAAK,cAAL,KAAK,GAAI,OAAO,CAAC,OAAO,EAAE;CAClC,CAAC,CAAA;AAOF,MAAM,KAAK,GAAG,GAAU,EAAE,CAAC,CAAC,EAAE,IAAI,EAAE,aAAa,CAAC,KAAK,EAAE,CAAC,CAAA;AAQ1D,MAAM,IAAI,GAAG,CAAI,KAAQ,EAAW,EAAE,CAAC,CAAC;IACtC,IAAI,EAAE,aAAa,CAAC,IAAI;IACxB,KAAK;CACN,CAAC,CAAA;AAOF,MAAM,KAAK,GAAG,GAAU,EAAE,CAAC,CAAC;IAC1B,IAAI,EAAE,aAAa,CAAC,KAAK;CAC1B,CAAC,CAAA;AAaF,MAAM,IAAI,GAAG,CACX,UAAsE,EAC7D,EAAE,CAAC,CAAC;IACb,IAAI,EAAE,aAAa,CAAC,IAAI;IACxB,UAAU;CACX,CAAC,CAAA;AAEW,QAAA,YAAY,GAAG;IAC1B,KAAK;IACL,KAAK;IACL,QAAQ;IACR,KAAK;CACN,CAAA;AAEY,QAAA,SAAS,GAAG;IACvB,IAAI;IACJ,KAAK;IACL,QAAQ;IACR,KAAK;IACL,IAAI;CACL,CAAA","sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { PaymentError } from '..'\nimport { StreamRequest, StreamReply, RequestBuilder } from '../request'\n\n/**\n * Controllers orchestrate when packets are sent, their amounts, and data.\n * Each controller implements its own business logic to handle a different part of the payment or STREAM protocol.\n */\nexport interface StreamController {\n  /**\n   * Controllers iteratively construct the next request and signal the status of the request attempt:\n   * - `RequestState.Ready`    -- ready to apply and send this request,\n   * - `RequestState.Error`    -- to immediately end the send loop with an error,\n   * - `RequestState.Schedule` -- to cancel this request attempt and try again at a later time,\n   * - `RequestState.Yield`    -- to cancel this request attempt and not directly schedule another.\n   *\n   * If any controller does not signal `Ready`, that request attempt will be cancelled.\n   *\n   * Note: since subsequent controllers may change the request or cancel it,\n   * no side effects should be performed here.\n   *\n   * @param request Proposed ILP Prepare and STREAM request\n   */\n  buildRequest?(request: RequestBuilder): RequestState\n\n  /**\n   * Apply side effects before sending an ILP Prepare over STREAM. Return a callback function to apply\n   * side effects from the corresponding ILP Fulfill or ILP Reject and STREAM reply.\n   *\n   * `applyRequest` is called for all controllers synchronously when the sending controller queues the\n   * request to be sent.\n   *\n   * The returned reply handler may also return an error to immediately end the send loop.\n   *\n   * @param request Finalized amounts and data of the ILP Prepare and STREAM request\n   */\n  applyRequest?(request: StreamRequest): ((reply: StreamReply) => PaymentError | void) | undefined\n}\n\nexport enum SendStateType {\n  /** Finish send loop successfully */\n  Done,\n  /** Finish send loop with an error */\n  Error,\n  /** Schedule another request attempt later. If applicable, cancels current attempt */\n  Schedule,\n  /** Do not schedule another attempt. If applicable, cancels current attempt */\n  Yield,\n  /** Ready to send and apply a request */\n  Ready,\n  /** Commit to send and apply the request */\n  Send,\n}\n\n/** States each controller may signal when building the next request */\nexport type RequestState = Error | Schedule | Yield | Ready\n\n/** States the sender may signal to determine the next state of the send loop */\nexport type SendState<T> = Error | Schedule | Yield | Send<T> | Done<T>\n\ntype Error = {\n  type: SendStateType.Error\n  value: PaymentError\n}\n\n/** Immediately end the loop and payment with an error. */\nconst Error = (error: PaymentError): Error => ({\n  type: SendStateType.Error,\n  value: error,\n})\n\ntype Schedule = {\n  type: SendStateType.Schedule\n  delay: Promise<any>\n}\n\n/**\n * Schedule another request attempt after the delay, or as soon as possible if\n * no delay was provided.\n */\nconst Schedule = (delay?: Promise<any>): Schedule => ({\n  type: SendStateType.Schedule,\n  delay: delay ?? Promise.resolve(),\n})\n\ntype Yield = {\n  type: SendStateType.Yield\n}\n\n/** Don't immediately schedule another request attempt. If applicable, cancel the current attempt. */\nconst Yield = (): Yield => ({ type: SendStateType.Yield })\n\ntype Done<T> = {\n  type: SendStateType.Done\n  value: T\n}\n\n/** Immediately resolve the send loop as successful. */\nconst Done = <T>(value: T): Done<T> => ({\n  type: SendStateType.Done,\n  value,\n})\n\ntype Ready = {\n  type: SendStateType.Ready\n}\n\n/** Ready for this request to be immediately applied and sent. */\nconst Ready = (): Ready => ({\n  type: SendStateType.Ready,\n})\n\ntype Send<T> = {\n  type: SendStateType.Send\n  applyReply: (reply: StreamReply) => Done<T> | Schedule | Yield | Error\n}\n\n/**\n * Apply and send the request.\n *\n * @param applyReply Callback to apply side effects from the reply, called synchronously after all other\n * controllers' reply handlers. The handler may resolve the the send loop, return an error, or re-schedule an attempt.\n */\nconst Send = <T>(\n  applyReply: (reply: StreamReply) => Done<T> | Schedule | Yield | Error\n): Send<T> => ({\n  type: SendStateType.Send,\n  applyReply,\n})\n\nexport const RequestState = {\n  Ready,\n  Error,\n  Schedule,\n  Yield,\n}\n\nexport const SendState = {\n  Done,\n  Error,\n  Schedule,\n  Yield,\n  Send,\n}\n"]}