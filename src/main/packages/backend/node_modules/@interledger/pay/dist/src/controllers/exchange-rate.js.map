{"version":3,"file":"exchange-rate.js","sourceRoot":"","sources":["../../../src/controllers/exchange-rate.ts"],"names":[],"mappings":";;;AAEA,oCAAiE;AAGjE,MAAa,sBAAsB;IACjC,YAEU,iBAAwB,aAAK,CAAC,EAAE,CAAC,WAAG,CAAC,IAAI,EAAE,WAAG,CAAC,GAAG,CAAC,EAGnD,iBAAgC,aAAK,CAAC,EAAE,CAAC,WAAG,CAAC,OAAO,EAAE,WAAG,CAAC,GAAG,CAAC;QAH9D,mBAAc,GAAd,cAAc,CAAqC;QAGnD,mBAAc,GAAd,cAAc,CAAgD;IACrE,CAAC;IAEJ,YAAY,CAAC,EAAE,YAAY,EAAE,GAAG,EAAiB;QAC/C,OAAO,CAAC,EAAE,iBAAiB,EAAe,EAAE,EAAE;YAE5C,IAAI,CAAC,YAAY,CAAC,UAAU,EAAE,EAAE;gBAC9B,OAAM;aACP;YAGD,IAAI,CAAC,iBAAiB,EAAE;gBACtB,OAAM;aACP;YAKD,MAAM,oBAAoB,GAAG,aAAK,CAAC,EAAE,CAAC,iBAAiB,CAAC,GAAG,CAAC,WAAG,CAAC,GAAG,CAAC,EAAE,YAAY,CAAC,CAAA;YACnF,MAAM,oBAAoB,GAAG,aAAK,CAAC,EAAE,CAAC,iBAAiB,EAAE,YAAY,CAAC,CAAA;YAGtE,MAAM,uBAAuB,GAC3B,oBAAoB,CAAC,mBAAmB,CAAC,IAAI,CAAC,cAAc,CAAC;gBAC7D,oBAAoB,CAAC,sBAAsB,CAAC,IAAI,CAAC,cAAc,CAAC,CAAA;YAClE,IAAI,uBAAuB,EAAE;gBAC3B,GAAG,CAAC,KAAK,CACP,8CAA8C,EAC9C,oBAAoB,EACpB,oBAAoB,CACrB,CAAA;gBACD,IAAI,CAAC,cAAc,GAAG,oBAAoB,CAAA;gBAC1C,IAAI,CAAC,cAAc,GAAG,oBAAoB,CAAA;gBAC1C,OAAM;aACP;YAED,IAAI,oBAAoB,CAAC,aAAa,CAAC,IAAI,CAAC,cAAc,CAAC,EAAE;gBAC3D,GAAG,CAAC,KAAK,CACP,kDAAkD,EAClD,IAAI,CAAC,cAAc,EACnB,oBAAoB,CACrB,CAAA;gBACD,IAAI,CAAC,cAAc,GAAG,oBAAoB,CAAA;aAC3C;YAED,IAAI,oBAAoB,CAAC,UAAU,CAAC,IAAI,CAAC,cAAc,CAAC,EAAE;gBACxD,GAAG,CAAC,KAAK,CACP,gDAAgD,EAChD,IAAI,CAAC,cAAc,EACnB,oBAAoB,CACrB,CAAA;gBACD,IAAI,CAAC,cAAc,GAAG,oBAAoB,CAAA;aAC3C;QACH,CAAC,CAAA;IACH,CAAC;IAED,iBAAiB;QACf,OAAO,IAAI,CAAC,cAAc,CAAA;IAC5B,CAAC;IAED,iBAAiB;QACf,OAAO,IAAI,CAAC,cAAc,CAAA;IAC5B,CAAC;IASD,yBAAyB,CAAC,YAAiB;QACzC,MAAM,iBAAiB,GAAG,YAAY,CAAC,aAAa,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,QAAQ,CAAC,WAAG,CAAC,OAAO,CAAC,CAAA;QAK/F,MAAM,kBAAkB,GAAG,YAAY;aACpC,YAAY,CAAC,IAAI,CAAC,cAAc,CAAC;aACjC,kBAAkB,CAAC,WAAG,CAAC,GAAG,CAAC;aAC3B,QAAQ,CAAC,WAAG,CAAC,OAAO,CAAC,CAAA;QAExB,OAAO,CAAC,iBAAiB,EAAE,kBAAkB,CAAC,CAAA;IAChD,CAAC;IAWD,oBAAoB,CAAC,iBAA8B;QAEjD,MAAM,cAAc,GAAG,IAAI,CAAC,cAAc,CAAC,UAAU,EAAE,CAAA;QACvD,IAAI,CAAC,cAAc,EAAE;YACnB,OAAM;SACP;QAED,MAAM,YAAY,GAAG,iBAAiB;aACnC,aAAa,CAAC,IAAI,CAAC,cAAc,CAAC,UAAU,EAAE,CAAC;aAC/C,GAAG,CAAC,WAAG,CAAC,GAAG,CAAC,CAAA;QACf,MAAM,aAAa,GAAG,iBAAiB,CAAC,YAAY,CAAC,cAAc,CAAC,CAAA;QACpE,OAAO,CAAC,YAAY,EAAE,aAAa,CAAC,CAAA;IACtC,CAAC;CACF;AAjHD,wDAiHC","sourcesContent":["import { StreamController } from '.'\nimport { StreamReply, StreamRequest } from '../request'\nimport { Int, PositiveInt, PositiveRatio, Ratio } from '../utils'\n\n/** Track realized exchange rates and estimate source/destination amounts */\nexport class ExchangeRateController implements StreamController {\n  constructor(\n    /** Realized exchange rate is greater than or equal to this ratio (inclusive): destination / source */\n    private lowerBoundRate: Ratio = Ratio.of(Int.ZERO, Int.ONE),\n\n    /** Realized exchange rate is less than this ratio (exclusive): (destination + 1) / source */\n    private upperBoundRate: PositiveRatio = Ratio.of(Int.MAX_U64, Int.ONE)\n  ) {}\n\n  applyRequest({ sourceAmount, log }: StreamRequest): (reply: StreamReply) => void {\n    return ({ destinationAmount }: StreamReply) => {\n      // Discard 0 amount packets\n      if (!sourceAmount.isPositive()) {\n        return\n      }\n\n      // Only track the rate for authentic STREAM replies\n      if (!destinationAmount) {\n        return\n      }\n\n      // Since intermediaries floor packet amounts, the exchange rate cannot be precisely computed:\n      // it's only known with some margin however. However, as we send packets of varying sizes,\n      // the upper and lower bounds should converge closer and closer to the real exchange rate.\n      const packetUpperBoundRate = Ratio.of(destinationAmount.add(Int.ONE), sourceAmount)\n      const packetLowerBoundRate = Ratio.of(destinationAmount, sourceAmount)\n\n      // If the exchange rate fluctuated and is \"out of bounds,\" reset it\n      const shouldResetExchangeRate =\n        packetUpperBoundRate.isLessThanOrEqualTo(this.lowerBoundRate) ||\n        packetLowerBoundRate.isGreaterThanOrEqualTo(this.upperBoundRate)\n      if (shouldResetExchangeRate) {\n        log.debug(\n          'exchange rate changed. resetting to [%s, %s]',\n          packetLowerBoundRate,\n          packetUpperBoundRate\n        )\n        this.upperBoundRate = packetUpperBoundRate\n        this.lowerBoundRate = packetLowerBoundRate\n        return\n      }\n\n      if (packetLowerBoundRate.isGreaterThan(this.lowerBoundRate)) {\n        log.debug(\n          'increasing probed rate lower bound from %s to %s',\n          this.lowerBoundRate,\n          packetLowerBoundRate\n        )\n        this.lowerBoundRate = packetLowerBoundRate\n      }\n\n      if (packetUpperBoundRate.isLessThan(this.upperBoundRate)) {\n        log.debug(\n          'reducing probed rate upper bound from %s to %s',\n          this.upperBoundRate,\n          packetUpperBoundRate\n        )\n        this.upperBoundRate = packetUpperBoundRate\n      }\n    }\n  }\n\n  getLowerBoundRate(): Ratio {\n    return this.lowerBoundRate\n  }\n\n  getUpperBoundRate(): PositiveRatio {\n    return this.upperBoundRate\n  }\n\n  /**\n   * Estimate the delivered amount from the given source amount.\n   * (1) Low-end estimate: at least this amount will get delivered, if the rate hasn't fluctuated.\n   * (2) High-end estimate: no more than this amount will get delivered, if the rate hasn't fluctuated.\n   *\n   * Cap the destination amounts at the max U64, since that's the most that an ILP packet can credit.\n   */\n  estimateDestinationAmount(sourceAmount: Int): [Int, Int] {\n    const lowEndDestination = sourceAmount.multiplyFloor(this.lowerBoundRate).orLesser(Int.MAX_U64)\n\n    // Since upper bound exchange rate is exclusive:\n    // If source amount converts exactly to an integer, destination amount MUST be 1 unit less\n    // If source amount doesn't convert precisely, we can't narrow it any better than that amount, floored ¯\\_(ツ)_/¯\n    const highEndDestination = sourceAmount\n      .multiplyCeil(this.upperBoundRate)\n      .saturatingSubtract(Int.ONE)\n      .orLesser(Int.MAX_U64)\n\n    return [lowEndDestination, highEndDestination]\n  }\n\n  /**\n   * Estimate the source amount that delivers the given destination amount.\n   * (1) Low-end estimate (may under-deliver, won't over-deliver): lowest source amount\n   *     that *may* deliver the given destination amount, if the rate hasn't fluctuated.\n   * (2) High-end estimate (won't under-deliver, may over-deliver): lowest source amount that\n   *     delivers at least the given destination amount, if the rate hasn't fluctuated.\n   *\n   * Returns `undefined` if the rate is 0 and it may not be possible to deliver anything.\n   */\n  estimateSourceAmount(destinationAmount: PositiveInt): [PositiveInt, PositiveInt] | undefined {\n    // If the exchange rate is a packet that delivered 0, the source amount is undefined\n    const lowerBoundRate = this.lowerBoundRate.reciprocal()\n    if (!lowerBoundRate) {\n      return\n    }\n\n    const lowEndSource = destinationAmount\n      .multiplyFloor(this.upperBoundRate.reciprocal())\n      .add(Int.ONE)\n    const highEndSource = destinationAmount.multiplyCeil(lowerBoundRate)\n    return [lowEndSource, highEndSource]\n  }\n}\n"]}