/// <reference types="node" />
import Long from 'long';
export declare const sha256: (preimage: Buffer) => Buffer;
export declare const hmac: (key: Buffer, message: Buffer) => Buffer;
export declare const generateEncryptionKey: (sharedSecret: Buffer) => Buffer;
export declare const generateFulfillmentKey: (sharedSecret: Buffer) => Buffer;
export declare const timeout: <T>(duration: number, promise: Promise<T>) => Promise<T>;
export declare const sleep: (ms: number) => Promise<void>;
export declare class Int {
    readonly value: bigint;
    static ZERO: Int;
    static ONE: PositiveInt;
    static TWO: PositiveInt;
    static MAX_U64: PositiveInt;
    private constructor();
    static from<T extends Int>(n: T): T;
    static from(n: Long): Int;
    static from(n: NonNegativeInteger): Int;
    static from(n: number): Int | undefined;
    static from(n: bigint): Int | undefined;
    static from(n: string): Int | undefined;
    static from(n: Int | bigint | number | string): Int | undefined;
    private static fromBigint;
    private static fromString;
    private static fromNumber;
    private static fromLong;
    add(n: PositiveInt): PositiveInt;
    add(n: Int): Int;
    saturatingSubtract(n: Int): Int;
    multiply(n: Int): Int;
    multiplyFloor(r: Ratio): Int;
    multiplyCeil(r: Ratio): Int;
    divide(d: PositiveInt): Int;
    divideCeil(d: PositiveInt): Int;
    modulo(n: PositiveInt): Int;
    isEqualTo(n: Int): boolean;
    isGreaterThan(n: Int): this is PositiveInt;
    isGreaterThanOrEqualTo(n: PositiveInt): this is PositiveInt;
    isGreaterThanOrEqualTo(n: Int): boolean;
    isLessThan(n: Int): boolean;
    isLessThanOrEqualTo(n: Int): boolean;
    isPositive(): this is PositiveInt;
    orLesser(n?: Int): Int;
    orGreater(n: PositiveInt): PositiveInt;
    orGreater(n?: Int): Int;
    toString(): string;
    toLong(): Long | undefined;
    valueOf(): number;
    toRatio(): Ratio;
}
export interface PositiveInt extends Int {
    add(n: Int): PositiveInt;
    multiply(n: PositiveInt): PositiveInt;
    multiply(n: Int): Int;
    multiplyCeil(r: PositiveRatio): PositiveInt;
    multiplyCeil(r: Ratio): Int;
    divideCeil(n: PositiveInt): PositiveInt;
    isEqualTo(n: Int): n is PositiveInt;
    isLessThan(n: Int): n is PositiveInt;
    isLessThanOrEqualTo(n: Int): n is PositiveInt;
    isPositive(): true;
    orLesser(n?: PositiveInt): PositiveInt;
    orLesser(n: Int): Int;
    orGreater(n?: Int): PositiveInt;
    toRatio(): PositiveRatio;
}
declare class Tag<N extends string> {
    protected __nominal: N;
}
export declare type Brand<T, N extends string> = T & Tag<N>;
export declare type NonNegativeRational = Brand<number, 'NonNegativeRational'>;
export declare const isNonNegativeRational: (o: unknown) => o is NonNegativeRational;
export declare type NonNegativeInteger = Brand<number, 'NonNegativeInteger'>;
export declare const isNonNegativeInteger: (o: number) => o is NonNegativeInteger;
export declare class Ratio {
    readonly a: Int;
    readonly b: PositiveInt;
    private constructor();
    static of(a: PositiveInt, b: PositiveInt): PositiveRatio;
    static of(a: Int, b: PositiveInt): Ratio;
    static from(n: NonNegativeRational): Ratio;
    static from(n: number): Ratio | undefined;
    reciprocal(): PositiveRatio | undefined;
    floor(): bigint;
    ceil(): bigint;
    isEqualTo(r: Ratio): boolean;
    isGreaterThan(r: Ratio): this is PositiveRatio;
    isGreaterThanOrEqualTo(r: PositiveRatio): this is PositiveRatio;
    isGreaterThanOrEqualTo(r: Ratio): boolean;
    isLessThan(r: Ratio): boolean;
    isLessThanOrEqualTo(r: Ratio): boolean;
    isPositive(): this is PositiveRatio;
    valueOf(): number;
    toString(): string;
    toJSON(): [string, string];
}
export interface PositiveRatio extends Ratio {
    readonly a: PositiveInt;
    readonly b: PositiveInt;
    reciprocal(): PositiveRatio;
    isEqualTo(r: Ratio): r is PositiveRatio;
    isLessThan(r: Ratio): r is PositiveRatio;
    isLessThanOrEqualTo(r: Ratio): r is PositiveRatio;
    isPositive(): true;
}
export {};
