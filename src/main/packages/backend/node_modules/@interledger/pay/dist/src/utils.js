"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Ratio = exports.isNonNegativeInteger = exports.isNonNegativeRational = exports.Int = exports.sleep = exports.timeout = exports.generateFulfillmentKey = exports.generateEncryptionKey = exports.hmac = exports.sha256 = void 0;
const long_1 = __importDefault(require("long"));
const crypto_1 = require("crypto");
const HASH_ALGORITHM = 'sha256';
const ENCRYPTION_KEY_STRING = Buffer.from('ilp_stream_encryption', 'utf8');
const FULFILLMENT_GENERATION_STRING = Buffer.from('ilp_stream_fulfillment', 'utf8');
const sha256 = (preimage) => (0, crypto_1.createHash)(HASH_ALGORITHM).update(preimage).digest();
exports.sha256 = sha256;
const hmac = (key, message) => (0, crypto_1.createHmac)(HASH_ALGORITHM, key).update(message).digest();
exports.hmac = hmac;
const generateEncryptionKey = (sharedSecret) => (0, exports.hmac)(sharedSecret, ENCRYPTION_KEY_STRING);
exports.generateEncryptionKey = generateEncryptionKey;
const generateFulfillmentKey = (sharedSecret) => (0, exports.hmac)(sharedSecret, FULFILLMENT_GENERATION_STRING);
exports.generateFulfillmentKey = generateFulfillmentKey;
const SHIFT_32 = BigInt(4294967296);
const timeout = (duration, promise) => {
    let timer;
    return Promise.race([
        new Promise((_, reject) => {
            timer = setTimeout(reject, duration);
        }),
        promise.finally(() => clearTimeout(timer)),
    ]);
};
exports.timeout = timeout;
const sleep = (ms) => new Promise((r) => setTimeout(r, ms));
exports.sleep = sleep;
class Int {
    constructor(n) {
        this.value = n;
    }
    static from(n) {
        if (n instanceof Int) {
            return new Int(n.value);
        }
        else if (typeof n === 'bigint') {
            return Int.fromBigint(n);
        }
        else if (typeof n === 'string') {
            return Int.fromString(n);
        }
        else if (typeof n === 'number') {
            return Int.fromNumber(n);
        }
        else if (long_1.default.isLong(n)) {
            return Int.fromLong(n);
        }
    }
    static fromBigint(n) {
        if (n >= 0) {
            return new Int(n);
        }
    }
    static fromString(n) {
        try {
            return Int.fromBigint(BigInt(n));
        }
        catch (_) { }
    }
    static fromNumber(n) {
        if ((0, exports.isNonNegativeInteger)(n)) {
            return new Int(BigInt(n));
        }
    }
    static fromLong(n) {
        const lsb = BigInt(n.getLowBitsUnsigned());
        const gsb = BigInt(n.getHighBitsUnsigned());
        return new Int(lsb + SHIFT_32 * gsb);
    }
    add(n) {
        return new Int(this.value + n.value);
    }
    saturatingSubtract(n) {
        return this.value >= n.value ? new Int(this.value - n.value) : Int.ZERO;
    }
    multiply(n) {
        return new Int(this.value * n.value);
    }
    multiplyFloor(r) {
        return new Int((this.value * r.a.value) / r.b.value);
    }
    multiplyCeil(r) {
        return this.multiply(r.a).divideCeil(r.b);
    }
    divide(d) {
        return new Int(this.value / d.value);
    }
    divideCeil(d) {
        return new Int((this.value + d.value - BigInt(1)) / d.value);
    }
    modulo(n) {
        return new Int(this.value % n.value);
    }
    isEqualTo(n) {
        return this.value === n.value;
    }
    isGreaterThan(n) {
        return this.value > n.value;
    }
    isGreaterThanOrEqualTo(n) {
        return this.value >= n.value;
    }
    isLessThan(n) {
        return this.value < n.value;
    }
    isLessThanOrEqualTo(n) {
        return this.value <= n.value;
    }
    isPositive() {
        return this.value > 0;
    }
    orLesser(n) {
        return !n ? this : this.value <= n.value ? this : n;
    }
    orGreater(n) {
        return !n ? this : this.value >= n.value ? this : n;
    }
    toString() {
        return this.value.toString();
    }
    toLong() {
        if (this.isGreaterThan(Int.MAX_U64)) {
            return;
        }
        const lsb = BigInt.asUintN(32, this.value);
        const gsb = (this.value - lsb) / SHIFT_32;
        return new long_1.default(Number(lsb), Number(gsb), true);
    }
    valueOf() {
        return Number(this.value);
    }
    toRatio() {
        return Ratio.of(this, Int.ONE);
    }
}
exports.Int = Int;
Int.ZERO = new Int(BigInt(0));
Int.ONE = new Int(BigInt(1));
Int.TWO = new Int(BigInt(2));
Int.MAX_U64 = new Int(BigInt('18446744073709551615'));
const isNonNegativeRational = (o) => typeof o === 'number' && Number.isFinite(o) && o >= 0;
exports.isNonNegativeRational = isNonNegativeRational;
const isNonNegativeInteger = (o) => Number.isInteger(o) && o >= 0;
exports.isNonNegativeInteger = isNonNegativeInteger;
class Ratio {
    constructor(a, b) {
        this.a = a;
        this.b = b;
    }
    static of(a, b) {
        return new Ratio(a, b);
    }
    static from(n) {
        if (!(0, exports.isNonNegativeRational)(n)) {
            return;
        }
        let e = 1;
        while (!Number.isInteger(n * e)) {
            e *= 10;
        }
        const a = Int.from(n * e);
        const b = Int.from(e);
        return new Ratio(a, b);
    }
    reciprocal() {
        if (this.a.isPositive()) {
            return Ratio.of(this.b, this.a);
        }
    }
    floor() {
        return this.a.divide(this.b).value;
    }
    ceil() {
        return this.a.divideCeil(this.b).value;
    }
    isEqualTo(r) {
        return this.a.value * r.b.value === this.b.value * r.a.value;
    }
    isGreaterThan(r) {
        return this.a.value * r.b.value > this.b.value * r.a.value;
    }
    isGreaterThanOrEqualTo(r) {
        return this.a.value * r.b.value >= this.b.value * r.a.value;
    }
    isLessThan(r) {
        return this.a.value * r.b.value < this.b.value * r.a.value;
    }
    isLessThanOrEqualTo(r) {
        return this.a.value * r.b.value <= this.b.value * r.a.value;
    }
    isPositive() {
        return this.a.isPositive();
    }
    valueOf() {
        return +this.a / +this.b;
    }
    toString() {
        return this.valueOf().toString();
    }
    toJSON() {
        return [this.a.toString(), this.b.toString()];
    }
}
exports.Ratio = Ratio;
//# sourceMappingURL=utils.js.map