{"version":3,"file":"payment.js","sourceRoot":"","sources":["../../../src/senders/payment.ts"],"names":[],"mappings":";;;AAAA,gDAA0E;AAC1E,oCAA8B;AAC9B,gEAK4C;AAC5C,0DAAqE;AACrE,gEAAqE;AACrE,0BAAwE;AAExE,gDAAuD;AACvD,gEAAqE;AACrE,oDAA0D;AAC1D,oDAA0D;AAC1D,kDAAwD;AACxD,gEAAsE;AACtE,sDAA4D;AAC5D,6DAA6E;AAC7E,wBAAgC;AAGhC,IAAY,WAKX;AALD,WAAY,WAAW;IAErB,sCAAuB,CAAA;IAEvB,8CAA+B,CAAA;AACjC,CAAC,EALW,WAAW,GAAX,mBAAW,KAAX,mBAAW,QAKtB;AAKD,MAAa,aAAc,SAAQ,eAA6B;IAsC9D,YAAY,EAAE,MAAM,EAAE,WAAW,EAAE,KAAK,EAAE,eAAe,EAAwB;QAC/E,KAAK,CAAC,MAAM,EAAE,WAAW,CAAC,CAAA;QAnCpB,eAAU,GAAG,WAAG,CAAC,IAAI,CAAA;QAGrB,oBAAe,GAAG,WAAG,CAAC,IAAI,CAAA;QAG1B,yBAAoB,GAAG,WAAG,CAAC,IAAI,CAAA;QAG/B,8BAAyB,GAAG,WAAG,CAAC,IAAI,CAAA;QAGpC,8BAAyB,GAAG,KAAK,CAAA;QAwBvC,MAAM,EAAE,cAAc,EAAE,GAAG,WAAW,CAAA;QAEtC,IAAI,CAAC,KAAK,GAAG,KAAK,CAAA;QAClB,IAAI,CAAC,eAAe,GAAG,eAAe,CAAA;QAEtC,IAAI,CAAC,mBAAmB,GAAG,IAAI,sCAAyB,CAAC,IAAI,CAAC,KAAK,CAAC,eAAe,CAAC,CAAA;QACpF,IAAI,CAAC,cAAc,GAAG,IAAI,sCAAsB,CAC9C,KAAK,CAAC,wBAAwB,EAC9B,KAAK,CAAC,yBAAyB,CAChC,CAAA;QAED,IAAI,CAAC,WAAW,GAAG;YACjB,IAAI,6BAAkB,CAAC,cAAc,CAAC;YACtC,IAAI,uCAAuB,CAAC,WAAW,CAAC;YACxC,IAAI,yBAAgB,EAAE;YACtB,IAAI,2BAAiB,EAAE;YACvB,IAAI,2BAAiB,EAAE;YACvB,IAAI,CAAC,mBAAmB;YACxB,IAAI,sCAAsB,CAAC,WAAW,CAAC;YACvC,IAAI,wBAAgB,EAAE;YACtB,IAAI,CAAC,cAAc;SACpB,CAAA;QAED,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,mBAAmB,CAAC,CAAA;IACrC,CAAC;IAED,SAAS,CAAC,OAAuB;;QAC/B,MAAM,EAAE,GAAG,EAAE,GAAG,OAAO,CAAA;QAGvB,MAAM,eAAe,GAAG,IAAI,CAAC,KAAK,CAAC,eAAe;aAC/C,kBAAkB,CAAC,IAAI,CAAC,UAAU,CAAC;aACnC,kBAAkB,CAAC,IAAI,CAAC,oBAAoB,CAAC,CAAA;QAChD,IAAI,CAAC,eAAe,CAAC,UAAU,EAAE,EAAE;YAEjC,OAAO,uBAAS,CAAC,KAAK,EAAE,CAAA;SACzB;QAGD,MAAM,eAAe,GAAG,IAAI,CAAC,mBAAmB,CAAC,sBAAsB,EAAE,CAAA;QACzE,IAAI,YAAY,GAAG,eAAe,CAAC,QAAQ,CAAC,eAAe,CAAC,CAAC,QAAQ,CAAC,WAAG,CAAC,OAAO,CAAC,CAAA;QAGlF,IAAI,gBAAgB,GAAG,KAAK,CAAA;QAG5B,IAAI,IAAI,CAAC,KAAK,CAAC,WAAW,KAAK,WAAW,CAAC,aAAa,EAAE;YACxD,MAAM,kBAAkB,GAAG,IAAI,CAAC,KAAK,CAAC,iBAAiB;iBACpD,kBAAkB,CAAC,IAAI,CAAC,eAAe,CAAC;iBACxC,kBAAkB,CAAC,IAAI,CAAC,yBAAyB,CAAC,CAAA;YACrD,IAAI,CAAC,kBAAkB,CAAC,UAAU,EAAE,EAAE;gBAGpC,OAAO,uBAAS,CAAC,KAAK,EAAE,CAAA;aACzB;YAED,MAAM,yBAAyB,GAC7B,MAAA,IAAI,CAAC,cAAc,CAAC,oBAAoB,CAAC,kBAAkB,CAAC,0CAAG,CAAC,CAAC,CAAA;YACnE,IAAI,CAAC,yBAAyB,EAAE;gBAC9B,GAAG,CAAC,IAAI,CAAC,qDAAqD,CAAC,CAAA;gBAC/D,OAAO,uBAAS,CAAC,KAAK,CAAC,gBAAY,CAAC,wBAAwB,CAAC,CAAA;aAC9D;YAED,YAAY,GAAG,YAAY,CAAC,QAAQ,CAAC,yBAAyB,CAAC,CAAA;YAC/D,gBAAgB,GAAG,YAAY,CAAC,SAAS,CAAC,yBAAyB,CAAC,CAAA;SACrE;aAAM;YACL,gBAAgB,GAAG,YAAY,CAAC,SAAS,CAAC,eAAe,CAAC,CAAA;SAC3D;QAID,MAAM,eAAe,GAAG,gBAAgB,IAAI,CAAC,IAAI,CAAC,yBAAyB,CAAA;QAC3E,MAAM,oBAAoB,GAAG,eAAe;YAC1C,CAAC,CAAC,YAAY,CAAC,kBAAkB,CAAC,WAAG,CAAC,GAAG,CAAC,CAAC,YAAY,CAAC,IAAI,CAAC,KAAK,CAAC,eAAe,CAAC;YACnF,CAAC,CAAC,YAAY,CAAC,YAAY,CAAC,IAAI,CAAC,KAAK,CAAC,eAAe,CAAC,CAAA;QAGzD,MAAM,CAAC,0BAA0B,EAAE,wBAAwB,CAAC,GAC1D,IAAI,CAAC,cAAc,CAAC,yBAAyB,CAAC,YAAY,CAAC,CAAA;QAC7D,IAAI,0BAA0B,CAAC,UAAU,CAAC,oBAAoB,CAAC,EAAE;YAC/D,GAAG,CAAC,IAAI,CAAC,8DAA8D,CAAC,CAAA;YACxE,OAAO,0BAAY,CAAC,KAAK,CAAC,gBAAY,CAAC,wBAAwB,CAAC,CAAA;SACjE;QAMD,IAAI,CAAC,oBAAoB,GAAG,IAAI,CAAC,oBAAoB,CAAC,GAAG,CAAC,YAAY,CAAC,CAAA;QACvE,IAAI,CAAC,yBAAyB,GAAG,IAAI,CAAC,yBAAyB,CAAC,GAAG,CAAC,wBAAwB,CAAC,CAAA;QAC7F,IAAI,CAAC,yBAAyB,GAAG,eAAe,CAAA;QAEhD,MAAA,IAAI,CAAC,eAAe,qDAAG,IAAI,CAAC,WAAW,EAAE,CAAC,CAAA;QAE1C,OAAO;aACJ,eAAe,CAAC,YAAY,CAAC;aAC7B,uBAAuB,CAAC,oBAAoB,CAAC;aAC7C,iBAAiB,EAAE;aACnB,SAAS,CAAC,IAAI,yBAAgB,CAAC,aAAa,CAAC,iBAAiB,EAAE,CAAC,CAAC,CAAC,CAAA;QAEtE,OAAO,uBAAS,CAAC,IAAI,CAAC,CAAC,KAAK,EAAE,EAAE;;YAG9B,MAAM,iBAAiB,GAAG,oBAAoB,CAAC,SAAS,CAAC,KAAK,CAAC,iBAAiB,CAAC,CAAA;YAEjF,IAAI,KAAK,CAAC,SAAS,EAAE,EAAE;gBACrB,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,YAAY,CAAC,CAAA;gBACnD,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,iBAAiB,CAAC,CAAA;gBAElE,GAAG,CAAC,KAAK,CACP,+DAA+D,EAC/D,YAAY,EACZ,iBAAiB,EACjB,oBAAoB,CACrB,CAAA;aACF;YAED,IAAI,KAAK,CAAC,QAAQ,EAAE,KAAI,MAAA,KAAK,CAAC,iBAAiB,0CAAE,UAAU,CAAC,oBAAoB,CAAC,CAAA,EAAE;gBACjF,GAAG,CAAC,KAAK,CACP,sEAAsE,EACtE,KAAK,CAAC,iBAAiB,EACvB,oBAAoB,CACrB,CAAA;aACF;YAGD,IAAI,CAAC,oBAAoB,GAAG,IAAI,CAAC,oBAAoB,CAAC,kBAAkB,CAAC,YAAY,CAAC,CAAA;YACtF,IAAI,CAAC,yBAAyB;gBAC5B,IAAI,CAAC,yBAAyB,CAAC,kBAAkB,CAAC,wBAAwB,CAAC,CAAA;YAE7E,IAAI,KAAK,CAAC,QAAQ,EAAE,IAAI,eAAe,EAAE;gBACvC,IAAI,CAAC,yBAAyB,GAAG,KAAK,CAAA;aACvC;YAED,GAAG,CAAC,KAAK,CACP,0CAA0C,EAC1C,IAAI,CAAC,UAAU,EACf,IAAI,CAAC,KAAK,CAAC,eAAe,EAC1B,IAAI,CAAC,oBAAoB,CAC1B,CAAA;YACD,GAAG,CAAC,KAAK,CACP,mEAAmE,EACnE,IAAI,CAAC,eAAe,EACpB,IAAI,CAAC,KAAK,CAAC,iBAAiB,EAC5B,IAAI,CAAC,yBAAyB,CAC/B,CAAA;YAED,IAAI,CAAC,mBAAmB,CAAC,KAAK,CAAC,CAAA;YAE/B,MAAA,IAAI,CAAC,eAAe,qDAAG,IAAI,CAAC,WAAW,EAAE,CAAC,CAAA;YAG1C,IAAI,KAAK,CAAC,SAAS,EAAE,EAAE;gBACrB,IAAI,CAAC,KAAK,CAAC,iBAAiB,EAAE;oBAE5B,GAAG,CAAC,IAAI,CAAC,gEAAgE,CAAC,CAAA;oBAC1E,OAAO,uBAAS,CAAC,KAAK,CAAC,gBAAY,CAAC,yBAAyB,CAAC,CAAA;iBAC/D;qBAAM,IAAI,KAAK,CAAC,iBAAiB,CAAC,UAAU,CAAC,oBAAoB,CAAC,EAAE;oBACnE,GAAG,CAAC,IAAI,CACN,sHAAsH,EACtH,iBAAiB,EACjB,oBAAoB,CACrB,CAAA;oBACD,OAAO,uBAAS,CAAC,KAAK,CAAC,gBAAY,CAAC,yBAAyB,CAAC,CAAA;iBAC/D;aACF;YAED,MAAM,aAAa,GACjB,IAAI,CAAC,KAAK,CAAC,WAAW,KAAK,WAAW,CAAC,SAAS;gBAChD,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC,eAAe,CAAC,CAAA;YACvD,IAAI,aAAa,EAAE;gBACjB,GAAG,CAAC,KAAK,CAAC,6CAA6C,CAAC,CAAA;gBACxD,OAAO,uBAAS,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC,CAAA;aAC1C;YAED,MAAM,iBAAiB,GACrB,IAAI,CAAC,KAAK,CAAC,WAAW,KAAK,WAAW,CAAC,aAAa;gBACpD,IAAI,CAAC,eAAe,CAAC,sBAAsB,CAAC,IAAI,CAAC,KAAK,CAAC,iBAAiB,CAAC;gBACzE,CAAC,IAAI,CAAC,oBAAoB,CAAC,UAAU,EAAE,CAAA;YACzC,IAAI,iBAAiB,EAAE;gBACrB,GAAG,CAAC,KAAK,CAAC,kDAAkD,CAAC,CAAA;gBAC7D,OAAO,uBAAS,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC,CAAA;aAC1C;YAED,IAAI,CAAC,gBAAgB;gBACnB,MAAA,MAAA,IAAI,CAAC,gBAAgB,CAAC,KAAK,CAAC,0CAAE,SAAS,CAAC,IAAI,CAAC,gBAAgB,CAAC,mCAAI,IAAI,CAAC,gBAAgB,CAAA;YACzF,IAAI,MAAA,IAAI,CAAC,gBAAgB,0CAAE,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,iBAAiB,CAAC,EAAE;gBACnE,GAAG,CAAC,KAAK,CACP,iGAAiG,EACjG,IAAI,CAAC,KAAK,CAAC,iBAAiB,EAC5B,IAAI,CAAC,gBAAgB,CACtB,CAAA;gBACD,OAAO,uBAAS,CAAC,KAAK,CAAC,gBAAY,CAAC,sBAAsB,CAAC,CAAA;aAC5D;YAID,OAAO,uBAAS,CAAC,QAAQ,EAAE,CAAA;QAC7B,CAAC,CAAC,CAAA;IACJ,CAAC;IAED,WAAW;;QACT,OAAO;YACL,aAAa,EAAE,MAAA,IAAI,CAAC,aAAa,0CAAE,MAAM;YACzC,UAAU,EAAE,IAAI,CAAC,UAAU,CAAC,KAAK;YACjC,eAAe,EAAE,IAAI,CAAC,eAAe,CAAC,KAAK;YAC3C,oBAAoB,EAAE,IAAI,CAAC,oBAAoB,CAAC,KAAK;YACrD,yBAAyB,EAAE,IAAI,CAAC,yBAAyB,CAAC,KAAK;SAChE,CAAA;IACH,CAAC;IAEO,gBAAgB,CAAC,EAAE,MAAM,EAAe;;QAC9C,OAAO,MAAA,MAAM,aAAN,MAAM,uBAAN,MAAM,CACT,MAAM,CAAC,CAAC,KAAK,EAAgC,EAAE,CAAC,KAAK,CAAC,IAAI,KAAK,kBAAS,CAAC,cAAc,EACxF,MAAM,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,KAAK,CAAC,QAAQ,CAAC,MAAM,CAAC,aAAa,CAAC,iBAAiB,CAAC,EACxE,GAAG,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,WAAG,CAAC,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC,0CAAG,CAAC,CAAC,CAAA;IACpD,CAAC;IAEO,mBAAmB,CAAC,EAAE,GAAG,EAAE,MAAM,EAAe;;QAGtD,MAAM,aAAa,GAAG,MAAA,MAAM,aAAN,MAAM,uBAAN,MAAM,CAAE,IAAI,CAChC,CAAC,KAAK,EAA+B,EAAE,CAAC,KAAK,CAAC,IAAI,KAAK,kBAAS,CAAC,aAAa,CAC/E,0CAAE,OAAO,CAAA;QACV,IAAI,CAAC,aAAa,EAAE;YAClB,OAAM;SACP;QAGD,IAAI,OAAsB,CAAA;QAC1B,IAAI;YACF,OAAO,GAAG,IAAA,mCAAa,EAAC,aAAa,CAAC,CAAA;SACvC;QAAC,OAAO,CAAC,EAAE;YACV,OAAM;SACP;QAED,MAAM,gBAAgB,GAAG,WAAG,CAAC,IAAI,CAAC,OAAO,CAAC,aAAa,CAAC,CAAA;QACxD,IAAI,CAAC,IAAI,CAAC,aAAa,IAAI,gBAAgB,CAAC,aAAa,CAAC,IAAI,CAAC,aAAa,CAAC,aAAa,CAAC,EAAE;YAC3F,GAAG,CAAC,KAAK,CAAC,sCAAsC,EAAE,gBAAgB,CAAC,CAAA;YACnE,IAAI,CAAC,aAAa,GAAG;gBACnB,aAAa,EAAE,gBAAgB;gBAC/B,MAAM,EAAE,aAAa;aACtB,CAAA;SACF;IACH,CAAC;;AA5RH,sCA6RC;AA5RQ,+BAAiB,GAAG,CAAC,CAAA","sourcesContent":["import { RequestState, SendState, StreamController } from '../controllers'\nimport { Int } from '../utils'\nimport {\n  StreamMaxMoneyFrame,\n  FrameType,\n  StreamMoneyFrame,\n  StreamReceiptFrame,\n} from 'ilp-protocol-stream/dist/src/packet'\nimport { MaxPacketAmountController } from '../controllers/max-packet'\nimport { ExchangeRateController } from '../controllers/exchange-rate'\nimport { IntQuote, PaymentError, PaymentProgress, PayOptions } from '..'\nimport { RequestBuilder, StreamReply } from '../request'\nimport { PacingController } from '../controllers/pacer'\nimport { AssetDetailsController } from '../controllers/asset-details'\nimport { TimeoutController } from '../controllers/timeout'\nimport { FailureController } from '../controllers/failure'\nimport { ExpiryController } from '../controllers/expiry'\nimport { EstablishmentController } from '../controllers/establishment'\nimport { SequenceController } from '../controllers/sequence'\nimport { decodeReceipt, Receipt as StreamReceipt } from 'ilp-protocol-stream'\nimport { StreamSender } from '.'\n\n/** Completion criteria of the payment */\nexport enum PaymentType {\n  /** Send up to a maximum source amount */\n  FixedSend = 'FixedSend',\n  /** Send to meet a minimum delivery amount, bounding the source amount and rates */\n  FixedDelivery = 'FixedDelivery',\n}\n\ntype PaymentSenderOptions = Omit<PayOptions, 'quote'> & { quote: IntQuote }\n\n/** Controller to track the payment status and compute amounts to send and deliver */\nexport class PaymentSender extends StreamSender<PaymentProgress> {\n  static DEFAULT_STREAM_ID = 1\n\n  /** Total amount sent and fulfilled, in scaled units of the sending account */\n  private amountSent = Int.ZERO\n\n  /** Total amount delivered and fulfilled, in scaled units of the receiving account */\n  private amountDelivered = Int.ZERO\n\n  /** Amount sent that is yet to be fulfilled or rejected, in scaled units of the sending account */\n  private sourceAmountInFlight = Int.ZERO\n\n  /** Estimate of the amount that may be delivered from in-flight packets, in scaled units of the receiving account */\n  private destinationAmountInFlight = Int.ZERO\n\n  /** Was the rounding error shortfall applied to an in-flight or delivered packet? */\n  private appliedRoundingCorrection = false\n\n  /** Maximum amount the recipient can receive on the default stream */\n  private remoteReceiveMax?: Int\n\n  /** Greatest STREAM receipt and amount, to prove delivery to a third-party verifier */\n  private latestReceipt?: {\n    totalReceived: Int\n    buffer: Buffer\n  }\n\n  /** Payment execution and minimum rates */\n  private readonly quote: IntQuote\n\n  /** Callback to pass updates as packets are sent and received */\n  private readonly progressHandler?: (status: PaymentProgress) => void\n\n  protected readonly controllers: StreamController[]\n\n  private readonly rateCalculator: ExchangeRateController\n  private readonly maxPacketController: MaxPacketAmountController\n\n  constructor({ plugin, destination, quote, progressHandler }: PaymentSenderOptions) {\n    super(plugin, destination)\n    const { requestCounter } = destination\n\n    this.quote = quote\n    this.progressHandler = progressHandler\n\n    this.maxPacketController = new MaxPacketAmountController(this.quote.maxPacketAmount)\n    this.rateCalculator = new ExchangeRateController(\n      quote.lowEstimatedExchangeRate,\n      quote.highEstimatedExchangeRate\n    )\n\n    this.controllers = [\n      new SequenceController(requestCounter),\n      new EstablishmentController(destination),\n      new ExpiryController(),\n      new FailureController(),\n      new TimeoutController(),\n      this.maxPacketController,\n      new AssetDetailsController(destination),\n      new PacingController(),\n      this.rateCalculator,\n    ]\n\n    this.log.debug('starting payment.')\n  }\n\n  nextState(request: RequestBuilder): SendState<PaymentProgress> {\n    const { log } = request\n\n    // Ensure we never overpay the maximum source amount\n    const availableToSend = this.quote.maxSourceAmount\n      .saturatingSubtract(this.amountSent)\n      .saturatingSubtract(this.sourceAmountInFlight)\n    if (!availableToSend.isPositive()) {\n      // If we've sent as much as we can, next attempt will only be scheduled after an in-flight request finishes\n      return SendState.Yield()\n    }\n\n    // Compute source amount (always positive)\n    const maxPacketAmount = this.maxPacketController.getNextMaxPacketAmount()\n    let sourceAmount = availableToSend.orLesser(maxPacketAmount).orLesser(Int.MAX_U64)\n\n    // Does this request complete the payment, so should the rounding correction be applied?\n    let completesPayment = false\n\n    // Apply fixed delivery limits\n    if (this.quote.paymentType === PaymentType.FixedDelivery) {\n      const remainingToDeliver = this.quote.minDeliveryAmount\n        .saturatingSubtract(this.amountDelivered)\n        .saturatingSubtract(this.destinationAmountInFlight)\n      if (!remainingToDeliver.isPositive()) {\n        // If we've already sent enough to potentially complete the payment,\n        // next attempt will only be scheduled after an in-flight request finishes\n        return SendState.Yield()\n      }\n\n      const sourceAmountDeliveryLimit =\n        this.rateCalculator.estimateSourceAmount(remainingToDeliver)?.[1]\n      if (!sourceAmountDeliveryLimit) {\n        log.warn('payment cannot complete: exchange rate dropped to 0')\n        return SendState.Error(PaymentError.InsufficientExchangeRate)\n      }\n\n      sourceAmount = sourceAmount.orLesser(sourceAmountDeliveryLimit)\n      completesPayment = sourceAmount.isEqualTo(sourceAmountDeliveryLimit)\n    } else {\n      completesPayment = sourceAmount.isEqualTo(availableToSend)\n    }\n\n    // Enforce the minimum exchange rate.\n    // Allow up to 1 source unit to be lost to rounding only *on the final packet*.\n    const applyCorrection = completesPayment && !this.appliedRoundingCorrection\n    const minDestinationAmount = applyCorrection\n      ? sourceAmount.saturatingSubtract(Int.ONE).multiplyCeil(this.quote.minExchangeRate)\n      : sourceAmount.multiplyCeil(this.quote.minExchangeRate)\n\n    // If the min destination amount isn't met, the rate dropped and payment cannot be completed.\n    const [projectedDestinationAmount, highEndDestinationAmount] =\n      this.rateCalculator.estimateDestinationAmount(sourceAmount)\n    if (projectedDestinationAmount.isLessThan(minDestinationAmount)) {\n      log.warn('payment cannot complete: exchange rate dropped below minimum')\n      return RequestState.Error(PaymentError.InsufficientExchangeRate)\n    }\n\n    // Rate calculator caps projected destination amounts to U64,\n    // so that checks against `minDestinationAmount` overflowing U64 range\n\n    // Update in-flight amounts (request will be applied synchronously)\n    this.sourceAmountInFlight = this.sourceAmountInFlight.add(sourceAmount)\n    this.destinationAmountInFlight = this.destinationAmountInFlight.add(highEndDestinationAmount)\n    this.appliedRoundingCorrection = applyCorrection\n\n    this.progressHandler?.(this.getProgress())\n\n    request\n      .setSourceAmount(sourceAmount)\n      .setMinDestinationAmount(minDestinationAmount)\n      .enableFulfillment()\n      .addFrames(new StreamMoneyFrame(PaymentSender.DEFAULT_STREAM_ID, 1))\n\n    return SendState.Send((reply) => {\n      // Delivered amount must be *at least* the minimum acceptable amount we told the receiver\n      // No matter what, since they fulfilled it, we must assume they got at least the minimum\n      const destinationAmount = minDestinationAmount.orGreater(reply.destinationAmount)\n\n      if (reply.isFulfill()) {\n        this.amountSent = this.amountSent.add(sourceAmount)\n        this.amountDelivered = this.amountDelivered.add(destinationAmount)\n\n        log.debug(\n          'accounted for fulfill. sent=%s delivered=%s minDestination=%s',\n          sourceAmount,\n          destinationAmount,\n          minDestinationAmount\n        )\n      }\n\n      if (reply.isReject() && reply.destinationAmount?.isLessThan(minDestinationAmount)) {\n        log.debug(\n          'packet rejected for insufficient rate. received=%s minDestination=%s',\n          reply.destinationAmount,\n          minDestinationAmount\n        )\n      }\n\n      // Update in-flight amounts\n      this.sourceAmountInFlight = this.sourceAmountInFlight.saturatingSubtract(sourceAmount)\n      this.destinationAmountInFlight =\n        this.destinationAmountInFlight.saturatingSubtract(highEndDestinationAmount)\n      // If this packet failed (e.g. for some other reason), refund the delivery deficit so it may be retried\n      if (reply.isReject() && applyCorrection) {\n        this.appliedRoundingCorrection = false\n      }\n\n      log.debug(\n        'payment sent %s of %s (max). inflight=%s',\n        this.amountSent,\n        this.quote.maxSourceAmount,\n        this.sourceAmountInFlight\n      )\n      log.debug(\n        'payment delivered %s of %s (min). inflight=%s (destination units)',\n        this.amountDelivered,\n        this.quote.minDeliveryAmount,\n        this.destinationAmountInFlight\n      )\n\n      this.updateStreamReceipt(reply)\n\n      this.progressHandler?.(this.getProgress())\n\n      // Handle protocol violations after all accounting has been performed\n      if (reply.isFulfill()) {\n        if (!reply.destinationAmount) {\n          // Technically, an intermediary could strip the data so we can't ascertain whose fault this is\n          log.warn('ending payment: packet fulfilled with no authentic STREAM data')\n          return SendState.Error(PaymentError.ReceiverProtocolViolation)\n        } else if (reply.destinationAmount.isLessThan(minDestinationAmount)) {\n          log.warn(\n            'ending payment: receiver violated procotol. packet fulfilled below min exchange rate. delivered=%s minDestination=%s',\n            destinationAmount,\n            minDestinationAmount\n          )\n          return SendState.Error(PaymentError.ReceiverProtocolViolation)\n        }\n      }\n\n      const paidFixedSend =\n        this.quote.paymentType === PaymentType.FixedSend &&\n        this.amountSent.isEqualTo(this.quote.maxSourceAmount) // Amount in flight is always 0 if this is true\n      if (paidFixedSend) {\n        log.debug('payment complete: paid fixed source amount.')\n        return SendState.Done(this.getProgress())\n      }\n\n      const paidFixedDelivery =\n        this.quote.paymentType === PaymentType.FixedDelivery &&\n        this.amountDelivered.isGreaterThanOrEqualTo(this.quote.minDeliveryAmount) &&\n        !this.sourceAmountInFlight.isPositive()\n      if (paidFixedDelivery) {\n        log.debug('payment complete: paid fixed destination amount.')\n        return SendState.Done(this.getProgress())\n      }\n\n      this.remoteReceiveMax =\n        this.updateReceiveMax(reply)?.orGreater(this.remoteReceiveMax) ?? this.remoteReceiveMax\n      if (this.remoteReceiveMax?.isLessThan(this.quote.minDeliveryAmount)) {\n        log.error(\n          'ending payment: minimum delivery amount is too much for recipient. minDelivery=%s receiveMax=%s',\n          this.quote.minDeliveryAmount,\n          this.remoteReceiveMax\n        )\n        return SendState.Error(PaymentError.IncompatibleReceiveMax)\n      }\n\n      // Since payment isn't complete yet, immediately queue attempt to send more money\n      // (in case we were at max in flight previously)\n      return SendState.Schedule()\n    })\n  }\n\n  getProgress(): PaymentProgress {\n    return {\n      streamReceipt: this.latestReceipt?.buffer,\n      amountSent: this.amountSent.value,\n      amountDelivered: this.amountDelivered.value,\n      sourceAmountInFlight: this.sourceAmountInFlight.value,\n      destinationAmountInFlight: this.destinationAmountInFlight.value,\n    }\n  }\n\n  private updateReceiveMax({ frames }: StreamReply): Int | undefined {\n    return frames\n      ?.filter((frame): frame is StreamMaxMoneyFrame => frame.type === FrameType.StreamMaxMoney)\n      .filter((frame) => frame.streamId.equals(PaymentSender.DEFAULT_STREAM_ID))\n      .map((frame) => Int.from(frame.receiveMax))?.[0]\n  }\n\n  private updateStreamReceipt({ log, frames }: StreamReply): void {\n    // Check for receipt frame\n    // No need to check streamId, since we only send over stream=1\n    const receiptBuffer = frames?.find(\n      (frame): frame is StreamReceiptFrame => frame.type === FrameType.StreamReceipt\n    )?.receipt\n    if (!receiptBuffer) {\n      return\n    }\n\n    // Decode receipt, discard if invalid\n    let receipt: StreamReceipt\n    try {\n      receipt = decodeReceipt(receiptBuffer)\n    } catch (_) {\n      return\n    }\n\n    const newTotalReceived = Int.from(receipt.totalReceived)\n    if (!this.latestReceipt || newTotalReceived.isGreaterThan(this.latestReceipt.totalReceived)) {\n      log.debug('updated latest stream receipt for %s', newTotalReceived)\n      this.latestReceipt = {\n        totalReceived: newTotalReceived,\n        buffer: receiptBuffer,\n      }\n    }\n  }\n}\n"]}