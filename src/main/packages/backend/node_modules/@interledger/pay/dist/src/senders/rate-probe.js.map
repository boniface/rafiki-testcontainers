{"version":3,"file":"rate-probe.js","sourceRoot":"","sources":["../../../src/senders/rate-probe.ts"],"names":[],"mappings":"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","sourcesContent":["import { PaymentError, QuoteOptions } from '..'\nimport { SendState, StreamController } from '../controllers'\nimport { Int, PositiveInt, PositiveRatio, Ratio } from '../utils'\nimport { MaxPacketAmountController } from '../controllers/max-packet'\nimport { ExchangeRateController } from '../controllers/exchange-rate'\nimport { SequenceController } from '../controllers/sequence'\nimport { EstablishmentController } from '../controllers/establishment'\nimport { ExpiryController } from '../controllers/expiry'\nimport { FailureController } from '../controllers/failure'\nimport { AssetDetailsController } from '../controllers/asset-details'\nimport { PacingController } from '../controllers/pacer'\nimport { RequestBuilder } from '../request'\nimport { StreamSender } from '.'\n\nexport interface ProbeResult {\n  maxPacketAmount: PositiveInt\n  lowEstimatedExchangeRate: Ratio\n  highEstimatedExchangeRate: PositiveRatio\n}\n\n/** Establish exchange rate bounds and path max packet amount capacity with test packets */\nexport class RateProbe extends StreamSender<ProbeResult> {\n  /** Duration in milliseconds before the rate probe fails */\n  private static TIMEOUT = 10_000\n\n  /** Largest test packet amount */\n  static MAX_PROBE_AMOUNT = Int.from(1_000_000_000_000) as PositiveInt\n\n  /**\n   * Initial barage of test packets amounts left to send (10^12 ... 10^3).\n   * Amounts < 1000 units are less likely to offer sufficient precision for quoting\n   */\n  private readonly remainingTestAmounts = [\n    Int.ZERO, // Shares limits & ensures connection is established, in case no asset probe\n    Int.from(10 ** 12),\n    Int.from(10 ** 11),\n    Int.from(10 ** 10),\n    Int.from(10 ** 9),\n    Int.from(10 ** 8),\n    Int.from(10 ** 7),\n    Int.from(10 ** 6),\n    Int.from(10 ** 5),\n    Int.from(10 ** 4),\n    Int.from(10 ** 3),\n  ] as Int[]\n\n  /**\n   * Amounts of all in-flight packets from subsequent (non-initial) probe packets,\n   * to ensure the same amount isn't sent continuously\n   */\n  private readonly inFlightAmounts = new Set<bigint>()\n\n  /** UNIX timestamp when the rate probe fails */\n  private deadline?: number\n\n  protected readonly controllers: StreamController[]\n\n  private maxPacketController: MaxPacketAmountController\n  private rateCalculator: ExchangeRateController\n\n  constructor({ plugin, destination }: QuoteOptions) {\n    super(plugin, destination)\n    const { requestCounter } = destination\n\n    this.rateCalculator = new ExchangeRateController()\n    this.maxPacketController = new MaxPacketAmountController()\n\n    // prettier-ignore\n    this.controllers = [\n      new SequenceController(requestCounter),   // Log sequence number in subsequent controllers\n      new EstablishmentController(destination), // Set destination address for all requests\n      new ExpiryController(),                   // Set expiry for all requests\n      new FailureController(),                  // Fail fast on terminal rejects or connection closes\n      this.maxPacketController,                 // Fail fast if max packet amount is 0\n      new AssetDetailsController(destination),  // Fail fast on destination asset conflicts\n      new PacingController(),                   // Limit frequency of requests\n      this.rateCalculator,\n    ]\n  }\n\n  nextState(request: RequestBuilder): SendState<ProbeResult> {\n    if (!this.deadline) {\n      this.deadline = Date.now() + RateProbe.TIMEOUT\n    } else if (Date.now() > this.deadline) {\n      request.log.error('rate probe failed. did not establish rate and/or path capacity')\n      return SendState.Error(PaymentError.RateProbeFailed)\n    }\n\n    const probeAmount = this.remainingTestAmounts.shift()\n    if (!probeAmount || this.inFlightAmounts.has(probeAmount.value)) {\n      return SendState.Yield()\n    }\n\n    // Send and commit the test packet\n    request.setSourceAmount(probeAmount)\n    this.inFlightAmounts.add(probeAmount.value)\n    return SendState.Send(() => {\n      this.inFlightAmounts.delete(probeAmount.value)\n\n      // If we further narrowed the max packet amount, use that amount next.\n      // Otherwise, no max packet limit is known, so retry this amount.\n      const nextProbeAmount = this.maxPacketController.getNextMaxPacketAmount() ?? probeAmount\n      if (!this.remainingTestAmounts.some((n) => n.isEqualTo(nextProbeAmount))) {\n        this.remainingTestAmounts.push(nextProbeAmount)\n      }\n\n      // Resolve rate probe if verified path capacity (ensures a rate is also known)\n      return this.maxPacketController.isProbeComplete()\n        ? SendState.Done({\n            lowEstimatedExchangeRate: this.rateCalculator.getLowerBoundRate(),\n            highEstimatedExchangeRate: this.rateCalculator.getUpperBoundRate(),\n            maxPacketAmount: this.maxPacketController.getMaxPacketAmountLimit(),\n          })\n        : SendState.Schedule() // Try sending another probing packet to narrow max packet amount\n    })\n  }\n}\n"]}