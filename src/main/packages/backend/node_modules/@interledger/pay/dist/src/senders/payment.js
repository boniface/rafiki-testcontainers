"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PaymentSender = exports.PaymentType = void 0;
const controllers_1 = require("@interledger/pay/dist/src/controllers");
const utils_1 = require("@interledger/pay/dist/src/utils");
const packet_1 = require("ilp-protocol-stream/dist/src/packet");
const max_packet_1 = require("@interledger/pay/dist/src/controllers/max-packet");
const exchange_rate_1 = require("@interledger/pay/dist/src/controllers/exchange-rate");
const __1 = require("@interledger/pay");
const pacer_1 = require("@interledger/pay/dist/src/controllers/pacer");
const asset_details_1 = require("@interledger/pay/dist/src/controllers/asset-details");
const timeout_1 = require("@interledger/pay/dist/src/controllers/timeout");
const failure_1 = require("@interledger/pay/dist/src/controllers/failure");
const expiry_1 = require("@interledger/pay/dist/src/controllers/expiry");
const establishment_1 = require("@interledger/pay/dist/src/controllers/establishment");
const sequence_1 = require("@interledger/pay/dist/src/controllers/sequence");
const ilp_protocol_stream_1 = require("ilp-protocol-stream");
const _1 = require("@interledger/pay/dist/src/senders");
var PaymentType;
(function (PaymentType) {
    PaymentType["FixedSend"] = "FixedSend";
    PaymentType["FixedDelivery"] = "FixedDelivery";
})(PaymentType = exports.PaymentType || (exports.PaymentType = {}));
class PaymentSender extends _1.StreamSender {
    constructor({ plugin, destination, quote, progressHandler }) {
        super(plugin, destination);
        this.amountSent = utils_1.Int.ZERO;
        this.amountDelivered = utils_1.Int.ZERO;
        this.sourceAmountInFlight = utils_1.Int.ZERO;
        this.destinationAmountInFlight = utils_1.Int.ZERO;
        this.appliedRoundingCorrection = false;
        const { requestCounter } = destination;
        this.quote = quote;
        this.progressHandler = progressHandler;
        this.maxPacketController = new max_packet_1.MaxPacketAmountController(this.quote.maxPacketAmount);
        this.rateCalculator = new exchange_rate_1.ExchangeRateController(quote.lowEstimatedExchangeRate, quote.highEstimatedExchangeRate);
        this.controllers = [
            new sequence_1.SequenceController(requestCounter),
            new establishment_1.EstablishmentController(destination),
            new expiry_1.ExpiryController(),
            new failure_1.FailureController(),
            new timeout_1.TimeoutController(),
            this.maxPacketController,
            new asset_details_1.AssetDetailsController(destination),
            new pacer_1.PacingController(),
            this.rateCalculator,
        ];
        this.log.debug('starting payment.');
    }
    nextState(request) {
        var _a, _b;
        const { log } = request;
        const availableToSend = this.quote.maxSourceAmount
            .saturatingSubtract(this.amountSent)
            .saturatingSubtract(this.sourceAmountInFlight);
        if (!availableToSend.isPositive()) {
            return controllers_1.SendState.Yield();
        }
        const maxPacketAmount = this.maxPacketController.getNextMaxPacketAmount();
        let sourceAmount = availableToSend.orLesser(maxPacketAmount).orLesser(utils_1.Int.MAX_U64);
        let completesPayment = false;
        if (this.quote.paymentType === PaymentType.FixedDelivery) {
            const remainingToDeliver = this.quote.minDeliveryAmount
                .saturatingSubtract(this.amountDelivered)
                .saturatingSubtract(this.destinationAmountInFlight);
            if (!remainingToDeliver.isPositive()) {
                return controllers_1.SendState.Yield();
            }
            const sourceAmountDeliveryLimit = (_a = this.rateCalculator.estimateSourceAmount(remainingToDeliver)) === null || _a === void 0 ? void 0 : _a[1];
            if (!sourceAmountDeliveryLimit) {
                log.warn('payment cannot complete: exchange rate dropped to 0');
                return controllers_1.SendState.Error(__1.PaymentError.InsufficientExchangeRate);
            }
            sourceAmount = sourceAmount.orLesser(sourceAmountDeliveryLimit);
            completesPayment = sourceAmount.isEqualTo(sourceAmountDeliveryLimit);
        }
        else {
            completesPayment = sourceAmount.isEqualTo(availableToSend);
        }
        const applyCorrection = completesPayment && !this.appliedRoundingCorrection;
        const minDestinationAmount = applyCorrection
            ? sourceAmount.saturatingSubtract(utils_1.Int.ONE).multiplyCeil(this.quote.minExchangeRate)
            : sourceAmount.multiplyCeil(this.quote.minExchangeRate);
        const [projectedDestinationAmount, highEndDestinationAmount] = this.rateCalculator.estimateDestinationAmount(sourceAmount);
        if (projectedDestinationAmount.isLessThan(minDestinationAmount)) {
            log.warn('payment cannot complete: exchange rate dropped below minimum');
            return controllers_1.RequestState.Error(__1.PaymentError.InsufficientExchangeRate);
        }
        this.sourceAmountInFlight = this.sourceAmountInFlight.add(sourceAmount);
        this.destinationAmountInFlight = this.destinationAmountInFlight.add(highEndDestinationAmount);
        this.appliedRoundingCorrection = applyCorrection;
        (_b = this.progressHandler) === null || _b === void 0 ? void 0 : _b.call(this, this.getProgress());
        request
            .setSourceAmount(sourceAmount)
            .setMinDestinationAmount(minDestinationAmount)
            .enableFulfillment()
            .addFrames(new packet_1.StreamMoneyFrame(PaymentSender.DEFAULT_STREAM_ID, 1));
        return controllers_1.SendState.Send((reply) => {
            var _a, _b, _c, _d, _e;
            const destinationAmount = minDestinationAmount.orGreater(reply.destinationAmount);
            if (reply.isFulfill()) {
                this.amountSent = this.amountSent.add(sourceAmount);
                this.amountDelivered = this.amountDelivered.add(destinationAmount);
                log.debug('accounted for fulfill. sent=%s delivered=%s minDestination=%s', sourceAmount, destinationAmount, minDestinationAmount);
            }
            if (reply.isReject() && ((_a = reply.destinationAmount) === null || _a === void 0 ? void 0 : _a.isLessThan(minDestinationAmount))) {
                log.debug('packet rejected for insufficient rate. received=%s minDestination=%s', reply.destinationAmount, minDestinationAmount);
            }
            this.sourceAmountInFlight = this.sourceAmountInFlight.saturatingSubtract(sourceAmount);
            this.destinationAmountInFlight =
                this.destinationAmountInFlight.saturatingSubtract(highEndDestinationAmount);
            if (reply.isReject() && applyCorrection) {
                this.appliedRoundingCorrection = false;
            }
            log.debug('payment sent %s of %s (max). inflight=%s', this.amountSent, this.quote.maxSourceAmount, this.sourceAmountInFlight);
            log.debug('payment delivered %s of %s (min). inflight=%s (destination units)', this.amountDelivered, this.quote.minDeliveryAmount, this.destinationAmountInFlight);
            this.updateStreamReceipt(reply);
            (_b = this.progressHandler) === null || _b === void 0 ? void 0 : _b.call(this, this.getProgress());
            if (reply.isFulfill()) {
                if (!reply.destinationAmount) {
                    log.warn('ending payment: packet fulfilled with no authentic STREAM data');
                    return controllers_1.SendState.Error(__1.PaymentError.ReceiverProtocolViolation);
                }
                else if (reply.destinationAmount.isLessThan(minDestinationAmount)) {
                    log.warn('ending payment: receiver violated procotol. packet fulfilled below min exchange rate. delivered=%s minDestination=%s', destinationAmount, minDestinationAmount);
                    return controllers_1.SendState.Error(__1.PaymentError.ReceiverProtocolViolation);
                }
            }
            const paidFixedSend = this.quote.paymentType === PaymentType.FixedSend &&
                this.amountSent.isEqualTo(this.quote.maxSourceAmount);
            if (paidFixedSend) {
                log.debug('payment complete: paid fixed source amount.');
                return controllers_1.SendState.Done(this.getProgress());
            }
            const paidFixedDelivery = this.quote.paymentType === PaymentType.FixedDelivery &&
                this.amountDelivered.isGreaterThanOrEqualTo(this.quote.minDeliveryAmount) &&
                !this.sourceAmountInFlight.isPositive();
            if (paidFixedDelivery) {
                log.debug('payment complete: paid fixed destination amount.');
                return controllers_1.SendState.Done(this.getProgress());
            }
            this.remoteReceiveMax =
                (_d = (_c = this.updateReceiveMax(reply)) === null || _c === void 0 ? void 0 : _c.orGreater(this.remoteReceiveMax)) !== null && _d !== void 0 ? _d : this.remoteReceiveMax;
            if ((_e = this.remoteReceiveMax) === null || _e === void 0 ? void 0 : _e.isLessThan(this.quote.minDeliveryAmount)) {
                log.error('ending payment: minimum delivery amount is too much for recipient. minDelivery=%s receiveMax=%s', this.quote.minDeliveryAmount, this.remoteReceiveMax);
                return controllers_1.SendState.Error(__1.PaymentError.IncompatibleReceiveMax);
            }
            return controllers_1.SendState.Schedule();
        });
    }
    getProgress() {
        var _a;
        return {
            streamReceipt: (_a = this.latestReceipt) === null || _a === void 0 ? void 0 : _a.buffer,
            amountSent: this.amountSent.value,
            amountDelivered: this.amountDelivered.value,
            sourceAmountInFlight: this.sourceAmountInFlight.value,
            destinationAmountInFlight: this.destinationAmountInFlight.value,
        };
    }
    updateReceiveMax({ frames }) {
        var _a;
        return (_a = frames === null || frames === void 0 ? void 0 : frames.filter((frame) => frame.type === packet_1.FrameType.StreamMaxMoney).filter((frame) => frame.streamId.equals(PaymentSender.DEFAULT_STREAM_ID)).map((frame) => utils_1.Int.from(frame.receiveMax))) === null || _a === void 0 ? void 0 : _a[0];
    }
    updateStreamReceipt({ log, frames }) {
        var _a;
        const receiptBuffer = (_a = frames === null || frames === void 0 ? void 0 : frames.find((frame) => frame.type === packet_1.FrameType.StreamReceipt)) === null || _a === void 0 ? void 0 : _a.receipt;
        if (!receiptBuffer) {
            return;
        }
        let receipt;
        try {
            receipt = (0, ilp_protocol_stream_1.decodeReceipt)(receiptBuffer);
        }
        catch (_) {
            return;
        }
        const newTotalReceived = utils_1.Int.from(receipt.totalReceived);
        if (!this.latestReceipt || newTotalReceived.isGreaterThan(this.latestReceipt.totalReceived)) {
            log.debug('updated latest stream receipt for %s', newTotalReceived);
            this.latestReceipt = {
                totalReceived: newTotalReceived,
                buffer: receiptBuffer,
            };
        }
    }
}
exports.PaymentSender = PaymentSender;
PaymentSender.DEFAULT_STREAM_ID = 1;
//# sourceMappingURL=payment.js.map