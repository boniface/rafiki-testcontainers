"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StreamServer = void 0;
const ilp_protocol_ildcp_1 = require("ilp-protocol-ildcp");
const oer_utils_1 = require("oer-utils");
const ilp_logger_1 = __importDefault(require("ilp-logger"));
const ilp_packet_1 = require("ilp-packet");
const utils_1 = require("@interledger/stream-receiver/dist/src/utils");
const packet_1 = require("ilp-protocol-stream/dist/src/packet");
const receipt_1 = require("ilp-protocol-stream/dist/src/util/receipt");
const long_1 = __importDefault(require("long"));
class StreamServer {
    constructor({ serverSecret, serverAddress }) {
        if (serverSecret.byteLength !== 32) {
            throw new Error('Server secret must be 32 bytes');
        }
        if (!(0, ilp_packet_1.isValidIlpAddress)(serverAddress)) {
            throw new Error('Invalid server base ILP address');
        }
        this.serverAddress = serverAddress;
        this.sharedSecretKeyGen = (0, utils_1.hmac)(serverSecret, StreamServer.SHARED_SECRET_GENERATION_STRING);
        this.connectionTokenKeyGen = (0, utils_1.hmac)(serverSecret, StreamServer.TOKEN_GENERATION_STRING);
    }
    generateCredentials(options = {}) {
        const { receiptSetup, asset } = options;
        if (receiptSetup) {
            if (receiptSetup.nonce.byteLength !== 16) {
                throw new Error('Failed to generate credentials: receipt nonce must be 16 bytes');
            }
            if (receiptSetup.secret.byteLength !== 32) {
                throw new Error('Failed to generate credentials: receipt secret must be 32 bytes');
            }
        }
        if (asset && !(0, ilp_protocol_ildcp_1.isValidAssetScale)(asset.scale)) {
            throw new Error('Failed to generate credentials: invalid asset scale');
        }
        const paymentTag = options.paymentTag ? Buffer.from(options.paymentTag, 'ascii') : undefined;
        const flags = (paymentTag ? StreamServer.TOKEN_FLAGS.PAYMENT_TAG : 0) |
            (receiptSetup ? StreamServer.TOKEN_FLAGS.RECEIPTS : 0) |
            (asset ? StreamServer.TOKEN_FLAGS.ASSET_DETAILS : 0);
        const writer = new oer_utils_1.Writer(StreamServer.TOKEN_GENERATION_BUFFER);
        writer.writeUInt8(flags);
        if (paymentTag) {
            writer.writeVarOctetString(paymentTag);
        }
        if (receiptSetup) {
            writer.write(receiptSetup.nonce);
            writer.write(receiptSetup.secret);
        }
        if (asset) {
            writer.writeVarOctetString(Buffer.from(asset.code, 'utf8'));
            writer.writeUInt8(asset.scale);
        }
        const token = (0, utils_1.encrypt)(this.connectionTokenKeyGen, writer.getBuffer());
        const sharedSecret = (0, utils_1.hmac)(this.sharedSecretKeyGen, token);
        const destinationAddress = `${this.serverAddress}.${(0, utils_1.base64url)(token)}`;
        if (!(0, ilp_packet_1.isValidIlpAddress)(destinationAddress)) {
            throw new Error('Failed to generate credentials: too much data to encode within an ILP address');
        }
        return {
            ilpAddress: destinationAddress,
            sharedSecret,
        };
    }
    extractLocalAddressSegment(destinationAddress) {
        const localAddressParts = destinationAddress.slice(this.serverAddress.length + 1).split('.');
        if (destinationAddress.startsWith(this.serverAddress + '.') && !!localAddressParts[0]) {
            return localAddressParts[0];
        }
    }
    decryptToken(token) {
        try {
            const details = {};
            const decryptedToken = (0, utils_1.decrypt)(this.connectionTokenKeyGen, token);
            const reader = new oer_utils_1.Reader(decryptedToken);
            const flags = reader.readUInt8Number();
            const hasPaymentTag = (flags & StreamServer.TOKEN_FLAGS.PAYMENT_TAG) !== 0;
            const hasReceiptDetails = (flags & StreamServer.TOKEN_FLAGS.RECEIPTS) !== 0;
            const hasAssetDetails = (flags & StreamServer.TOKEN_FLAGS.ASSET_DETAILS) !== 0;
            if (hasPaymentTag) {
                details.paymentTag = reader.readVarOctetString().toString('ascii');
            }
            if (hasReceiptDetails) {
                details.receiptSetup = {
                    nonce: reader.read(16),
                    secret: reader.read(32),
                };
            }
            if (hasAssetDetails) {
                details.asset = {
                    code: reader.readVarOctetString().toString(),
                    scale: reader.readUInt8Number(),
                };
            }
            return details;
        }
        catch (_) {
        }
    }
    decodePaymentTag(destinationAddress) {
        var _a;
        const token = this.extractLocalAddressSegment(destinationAddress);
        if (token) {
            return (_a = this.decryptToken(Buffer.from(token, 'base64'))) === null || _a === void 0 ? void 0 : _a.paymentTag;
        }
    }
    createReply(prepare) {
        const connectionId = (0, utils_1.sha256)(Buffer.from(prepare.destination, 'ascii')).toString('hex');
        const log = (0, ilp_logger_1.default)(`ilp-receiver:${connectionId.slice(0, 6)}`);
        const reply = new utils_1.ReplyBuilder().setIlpAddress(this.serverAddress);
        const localSegment = this.extractLocalAddressSegment(prepare.destination);
        if (!localSegment) {
            log.trace('got packet not addressed to the receiver. destination=%s', prepare.destination);
            return reply.buildReject(ilp_packet_1.IlpError.F02_UNREACHABLE);
        }
        const token = Buffer.from(localSegment, 'base64');
        const connectionDetails = this.decryptToken(token);
        if (!connectionDetails) {
            log.trace('invalid connection token: cannot attribute incoming packet. token=%s', localSegment);
            return reply.buildReject(ilp_packet_1.IlpError.F06_UNEXPECTED_PAYMENT);
        }
        const { paymentTag, receiptSetup, asset } = connectionDetails;
        log.debug('got incoming Prepare. amount: %s', prepare.amount);
        const sharedSecret = (0, utils_1.hmac)(this.sharedSecretKeyGen, token);
        const encryptionKey = (0, utils_1.hmac)(sharedSecret, StreamServer.ENCRYPTION_KEY_STRING);
        let streamRequest;
        try {
            streamRequest = packet_1.Packet._deserializeUnencrypted((0, utils_1.decrypt)(encryptionKey, prepare.data));
        }
        catch (_) {
            log.trace('rejecting with F06: failed to decrypt STREAM data');
            return reply.buildReject(ilp_packet_1.IlpError.F06_UNEXPECTED_PAYMENT);
        }
        if (+streamRequest.ilpPacketType !== ilp_packet_1.IlpPacketType.Prepare) {
            log.warn('rejecting with F00: invalid STREAM packet type');
            return reply.buildReject(ilp_packet_1.IlpError.F00_BAD_REQUEST);
        }
        log.debug('got authentic STREAM request. sequence: %s, min destination amount: %s', streamRequest.sequence, streamRequest.prepareAmount);
        log.trace('STREAM request frames: %o', streamRequest.frames);
        reply
            .setEncryptionKey(encryptionKey)
            .setSequence(streamRequest.sequence)
            .setReceivedAmount(prepare.amount);
        const closeFrame = streamRequest.frames.find((frame) => frame.type === packet_1.FrameType.ConnectionClose);
        if (closeFrame) {
            log.trace('client closed connection, rejecting with F99. code="%s" message="%s"', packet_1.ErrorCode[closeFrame.errorCode], closeFrame.errorMessage);
            return reply
                .addFrames(new packet_1.ConnectionCloseFrame(packet_1.ErrorCode.NoError, ''))
                .buildReject(ilp_packet_1.IlpError.F99_APPLICATION_ERROR);
        }
        const isNewConnection = streamRequest.frames.some((frame) => frame.type === packet_1.FrameType.ConnectionNewAddress);
        if (isNewConnection && asset) {
            log.trace('got new client address, replying with asset details: %s %s', asset.code, asset.scale);
            reply.addFrames(new packet_1.ConnectionAssetDetailsFrame(asset.code, asset.scale));
        }
        const receivedAmount = long_1.default.fromString(prepare.amount, true);
        const didReceiveMinimum = receivedAmount.greaterThanOrEqual(streamRequest.prepareAmount);
        if (!didReceiveMinimum) {
            return reply.buildReject(ilp_packet_1.IlpError.F99_APPLICATION_ERROR);
        }
        const fulfillmentKey = (0, utils_1.hmac)(sharedSecret, StreamServer.FULFILLMENT_GENERATION_STRING);
        const fulfillment = (0, utils_1.hmac)(fulfillmentKey, prepare.data);
        const isFulfillable = (0, utils_1.sha256)(fulfillment).equals(prepare.executionCondition);
        if (!isFulfillable) {
            return reply.buildReject(ilp_packet_1.IlpError.F99_APPLICATION_ERROR);
        }
        else if (receivedAmount.isZero()) {
            return reply.buildFulfill(fulfillment);
        }
        return {
            connectionId,
            paymentTag,
            setTotalReceived: (totalReceived) => {
                if (receiptSetup) {
                    const receipt = (0, receipt_1.createReceipt)({
                        ...receiptSetup,
                        totalReceived,
                        streamId: 1,
                    });
                    reply.addFrames(new packet_1.StreamReceiptFrame(1, receipt));
                }
            },
            accept: () => reply.buildFulfill(fulfillment),
            temporaryDecline: () => reply.buildReject(ilp_packet_1.IlpError.T00_INTERNAL_ERROR),
            finalDecline: () => reply
                .addFrames(new packet_1.ConnectionCloseFrame(packet_1.ErrorCode.NoError, ''))
                .buildReject(ilp_packet_1.IlpError.F99_APPLICATION_ERROR),
        };
    }
}
exports.StreamServer = StreamServer;
StreamServer.TOKEN_GENERATION_STRING = Buffer.from('ilp_stream_connection_token');
StreamServer.SHARED_SECRET_GENERATION_STRING = Buffer.from('ilp_stream_shared_secret');
StreamServer.ENCRYPTION_KEY_STRING = Buffer.from('ilp_stream_encryption');
StreamServer.FULFILLMENT_GENERATION_STRING = Buffer.from('ilp_stream_fulfillment');
StreamServer.TOKEN_GENERATION_BUFFER = Buffer.alloc(767);
StreamServer.TOKEN_FLAGS = {
    PAYMENT_TAG: 1,
    RECEIPTS: 2,
    ASSET_DETAILS: 4,
};
//# sourceMappingURL=index.js.map