{"version":3,"file":"request.js","sourceRoot":"","sources":["../../src/request.ts"],"names":[],"mappings":"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","sourcesContent":["import { Logger } from 'ilp-logger'\nimport {\n  deserializeIlpReply,\n  IlpError,\n  IlpErrorCode,\n  IlpPacketType,\n  IlpReject,\n  IlpReply,\n  isFulfill,\n  isReject,\n  serializeIlpPrepare,\n  IlpAddress,\n} from 'ilp-packet'\nimport { randomBytes } from 'crypto'\nimport { Frame, FrameType, Packet as StreamPacket } from 'ilp-protocol-stream/dist/src/packet'\nimport { generateEncryptionKey, generateFulfillmentKey, hmac, Int, sha256, timeout } from './utils'\n\nexport interface Plugin {\n  sendData(data: Buffer): Promise<Buffer>\n}\n\n/** Generate keys and serialization function to send ILP Prepares over STREAM */\nexport const generateKeys = (\n  plugin: Plugin,\n  sharedSecret: Buffer\n): ((request: StreamRequest) => Promise<StreamReply>) => {\n  const encryptionKey = generateEncryptionKey(sharedSecret)\n  const fulfillmentKey = generateFulfillmentKey(sharedSecret)\n\n  return async (request: StreamRequest): Promise<StreamReply> => {\n    // Create the STREAM request packet\n    const {\n      sequence,\n      sourceAmount,\n      destinationAddress,\n      minDestinationAmount,\n      frames,\n      isFulfillable,\n      expiresAt,\n      log,\n    } = request\n\n    const streamRequest = new StreamPacket(\n      sequence,\n      IlpPacketType.Prepare.valueOf(),\n      minDestinationAmount.toLong(),\n      frames\n    )\n\n    const data = await streamRequest.serializeAndEncrypt(encryptionKey)\n\n    let executionCondition: Buffer\n    let fulfillment: Buffer | undefined\n\n    if (isFulfillable) {\n      fulfillment = hmac(fulfillmentKey, data)\n      executionCondition = sha256(fulfillment)\n      log.debug(\n        'sending Prepare. amount=%s minDestinationAmount=%s frames=[%s]',\n        sourceAmount,\n        minDestinationAmount,\n        frames.map((f) => FrameType[f.type]).join()\n      )\n    } else {\n      executionCondition = randomBytes(32)\n      log.debug(\n        'sending unfulfillable Prepare. amount=%s frames=[%s]',\n        sourceAmount,\n        frames.map((f) => FrameType[f.type]).join()\n      )\n    }\n\n    log.trace('loading Prepare with frames: %o', frames)\n\n    // Create and serialize the ILP Prepare\n    const preparePacket = serializeIlpPrepare({\n      destination: destinationAddress,\n      amount: sourceAmount.toString(), // Max packet amount controller always limits this to U64\n      executionCondition,\n      expiresAt,\n      data,\n    })\n\n    // Send the packet!\n    const pendingReply = plugin\n      .sendData(preparePacket)\n      .then((data) => {\n        try {\n          return deserializeIlpReply(data)\n        } catch (_) {\n          return createReject(IlpError.F01_INVALID_PACKET)\n        }\n      })\n      .catch((err) => {\n        log.error('failed to send Prepare:', err)\n        return createReject(IlpError.T00_INTERNAL_ERROR)\n      })\n      .then((ilpReply) => {\n        if (!isFulfill(ilpReply) || !fulfillment || ilpReply.fulfillment.equals(fulfillment)) {\n          return ilpReply\n        }\n\n        log.error(\n          'got invalid fulfillment: %h. expected: %h, condition: %h',\n          ilpReply.fulfillment,\n          fulfillment,\n          executionCondition\n        )\n        return createReject(IlpError.F05_WRONG_CONDITION)\n      })\n\n    // Await reply and timeout if the packet expires\n    const timeoutDuration = expiresAt.getTime() - Date.now()\n    const ilpReply: IlpReply = await timeout(timeoutDuration, pendingReply).catch(() => {\n      log.error('request timed out.')\n      return createReject(IlpError.R00_TRANSFER_TIMED_OUT)\n    })\n\n    const streamReply = await StreamPacket.decryptAndDeserialize(\n      encryptionKey,\n      ilpReply.data\n    ).catch(() => undefined)\n\n    if (isFulfill(ilpReply)) {\n      log.debug('got Fulfill. sentAmount=%s', sourceAmount)\n    } else if (isReject(ilpReply)) {\n      log.debug('got %s Reject: %s', ilpReply.code, ILP_ERROR_CODES[ilpReply.code as IlpErrorCode])\n\n      if (ilpReply.message.length > 0 || ilpReply.triggeredBy.length > 0) {\n        log.trace('Reject message=\"%s\" triggeredBy=%s', ilpReply.message, ilpReply.triggeredBy)\n      }\n    } else {\n      throw new Error('ILP response is neither fulfillment nor rejection')\n    }\n\n    let responseFrames: Frame[] | undefined\n    let destinationAmount: Int | undefined\n\n    // Validate the STREAM reply from recipient\n    if (streamReply) {\n      if (streamReply.sequence.notEquals(sequence)) {\n        log.error('discarding STREAM reply: received invalid sequence %s', streamReply.sequence)\n      } else if (+streamReply.ilpPacketType === IlpPacketType.Reject && isFulfill(ilpReply)) {\n        // If receiver claimed they sent a Reject but we got a Fulfill, they lied!\n        // If receiver said they sent a Fulfill but we got a Reject, that's possible\n        log.error(\n          'discarding STREAM reply: received Fulfill, but recipient claims they sent a Reject'\n        )\n      } else {\n        responseFrames = streamReply.frames\n        destinationAmount = Int.from(streamReply.prepareAmount)\n\n        log.debug(\n          'got authentic STREAM reply. receivedAmount=%s frames=[%s]',\n          destinationAmount,\n          responseFrames.map((f) => FrameType[f.type]).join()\n        )\n        log.trace('STREAM reply frames: %o', responseFrames)\n      }\n    } else if (\n      (isFulfill(ilpReply) || ilpReply.code !== IlpError.F08_AMOUNT_TOO_LARGE) &&\n      ilpReply.data.byteLength > 0\n    ) {\n      // If there's data in a Fulfill or non-F08 reject, it is expected to be a valid STREAM packet\n      log.warn('data in reply unexpectedly failed decryption.')\n    }\n\n    return isFulfill(ilpReply)\n      ? new StreamFulfill(log, responseFrames, destinationAmount)\n      : new StreamReject(log, ilpReply, responseFrames, destinationAmount)\n  }\n}\n\n/** Mapping of ILP error codes to its error message */\nconst ILP_ERROR_CODES = {\n  // Final errors\n  F00: 'bad request',\n  F01: 'invalid packet',\n  F02: 'unreachable',\n  F03: 'invalid amount',\n  F04: 'insufficient destination amount',\n  F05: 'wrong condition',\n  F06: 'unexpected payment',\n  F07: 'cannot receive',\n  F08: 'amount too large',\n  F99: 'application error',\n  // Temporary errors\n  T00: 'internal error',\n  T01: 'peer unreachable',\n  T02: 'peer busy',\n  T03: 'connector busy',\n  T04: 'insufficient liquidity',\n  T05: 'rate limited',\n  T99: 'application error',\n  // Relative errors\n  R00: 'transfer timed out',\n  R01: 'insufficient source amount',\n  R02: 'insufficient timeout',\n  R99: 'application error',\n}\n\n/** Construct a simple ILP Reject packet */\nconst createReject = (code: IlpError): IlpReject => ({\n  code,\n  message: '',\n  triggeredBy: '',\n  data: Buffer.alloc(0),\n})\n\n/** Amounts and data to send a unique ILP Prepare over STREAM */\nexport interface StreamRequest {\n  /** ILP address of the recipient account */\n  destinationAddress: IlpAddress\n  /** Expiration timestamp when the ILP Prepare is void */\n  expiresAt: Date\n  /** Sequence number of the STREAM packet (u32) */\n  sequence: number\n  /** Amount to send in the ILP Prepare */\n  sourceAmount: Int\n  /** Minimum destination amount to tell the recipient (\"prepare amount\") */\n  minDestinationAmount: Int\n  /** Frames to load within the STREAM packet */\n  frames: Frame[]\n  /** Should the recipient be allowed to fulfill this request, or should it use a random condition? */\n  isFulfillable: boolean\n  /** Logger namespaced to this connection and request sequence number */\n  log: Logger\n}\n\n/** Builder to construct the next ILP Prepare and STREAM request */\nexport class RequestBuilder implements StreamRequest {\n  private request: StreamRequest\n\n  constructor(request?: Partial<StreamRequest>) {\n    this.request = {\n      destinationAddress: 'private.example' as IlpAddress,\n      expiresAt: new Date(),\n      sequence: 0,\n      sourceAmount: Int.ZERO,\n      minDestinationAmount: Int.ZERO,\n      frames: [],\n      isFulfillable: false,\n      log: new Logger('ilp-pay'),\n      ...request,\n    }\n  }\n\n  get destinationAddress(): IlpAddress {\n    return this.request.destinationAddress\n  }\n\n  get expiresAt(): Date {\n    return this.request.expiresAt\n  }\n\n  get sequence(): number {\n    return this.request.sequence\n  }\n\n  get sourceAmount(): Int {\n    return this.request.sourceAmount\n  }\n\n  get minDestinationAmount(): Int {\n    return this.request.minDestinationAmount\n  }\n\n  get frames(): Frame[] {\n    return this.request.frames\n  }\n\n  get isFulfillable(): boolean {\n    return this.request.isFulfillable\n  }\n\n  get log(): Logger {\n    return this.request.log\n  }\n\n  /** Set the ILP address of the destination of the ILP Prepare */\n  setDestinationAddress(address: IlpAddress): this {\n    this.request.destinationAddress = address\n    return this\n  }\n\n  /** Set the expiration time of the ILP Prepare */\n  setExpiry(expiresAt: Date): this {\n    this.request.expiresAt = expiresAt\n    return this\n  }\n\n  /** Set the sequence number of STREAM packet, to correlate the reply */\n  setSequence(sequence: number): this {\n    this.request.sequence = sequence\n    this.request.log = this.request.log.extend(sequence.toString())\n    return this\n  }\n\n  /** Set the source amount of the ILP Prepare */\n  setSourceAmount(sourceAmount: Int): this {\n    this.request.sourceAmount = sourceAmount\n    return this\n  }\n\n  /** Set the minimum destination amount for the receiver to fulfill the ILP Prepare */\n  setMinDestinationAmount(minDestinationAmount: Int): this {\n    this.request.minDestinationAmount = minDestinationAmount\n    return this\n  }\n\n  /** Add frames to include for the STREAM receiver */\n  addFrames(...frames: Frame[]): this {\n    this.request.frames = [...this.request.frames, ...frames]\n    return this\n  }\n\n  /** Enable the STREAM receiver to fulfill this ILP Prepare. By default, a random, unfulfillable condition is used. */\n  enableFulfillment(): this {\n    this.request.isFulfillable = true\n    return this\n  }\n\n  build(): StreamRequest {\n    return { ...this.request }\n  }\n}\n\nexport interface StreamReply {\n  /** Logger namespaced to this connection and request sequence number */\n  readonly log: Logger\n  /** Parsed frames from the STREAM response packet. Omitted if no authentic STREAM reply */\n  readonly frames?: Frame[]\n  /** Amount the recipient claimed to receive. Omitted if no authentic STREAM reply */\n  readonly destinationAmount?: Int\n  /**\n   * Did the recipient authenticate that they received the STREAM request packet?\n   * If they responded with a Fulfill or valid STREAM reply, they necessarily decoded the request\n   */\n  isAuthentic(): boolean\n  /** Is this an ILP Reject packet? */\n  isReject(): this is StreamReject\n  /** Is this an ILP Fulfill packet? */\n  isFulfill(): this is StreamFulfill\n}\n\nexport class StreamFulfill implements StreamReply {\n  readonly log: Logger\n  readonly frames?: Frame[]\n  readonly destinationAmount?: Int\n\n  constructor(log: Logger, frames?: Frame[], destinationAmount?: Int) {\n    this.log = log\n    this.frames = frames\n    this.destinationAmount = destinationAmount\n  }\n\n  isAuthentic(): boolean {\n    return true\n  }\n\n  isReject(): this is StreamReject {\n    return false\n  }\n\n  isFulfill(): this is StreamFulfill {\n    return true\n  }\n}\n\nexport class StreamReject implements StreamReply {\n  readonly log: Logger\n  readonly frames?: Frame[]\n  readonly destinationAmount?: Int\n  readonly ilpReject: IlpReject\n\n  constructor(log: Logger, ilpReject: IlpReject, frames?: Frame[], destinationAmount?: Int) {\n    this.log = log\n    this.ilpReject = ilpReject\n    this.frames = frames\n    this.destinationAmount = destinationAmount\n  }\n\n  isAuthentic(): boolean {\n    return !!this.frames && !!this.destinationAmount\n  }\n\n  isReject(): this is StreamReject {\n    return true\n  }\n\n  isFulfill(): this is StreamFulfill {\n    return false\n  }\n}\n"]}