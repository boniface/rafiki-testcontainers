{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../src/senders/index.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { StreamController, SendState, SendStateType, RequestState } from '../controllers'\nimport { RequestBuilder, generateKeys, StreamRequest, StreamReply } from '../request'\nimport { isPaymentError, PaymentError } from '..'\nimport { PaymentDestination } from '../open-payments'\nimport createLogger, { Logger } from 'ilp-logger'\nimport { Plugin } from '../request'\nimport { sha256 } from '../utils'\n\n/**\n * Orchestrates all business rules to schedule and send a series of ILP/STREAM requests\n * to one unique destination.\n *\n * Sends and commits each request, and tracks completion criteria to\n * resolve the send loop to its own value.\n *\n * While other controllers hold \"veto\" power over individual request attempts,\n * only the sender explicitly commits to sending each request.\n */\nexport abstract class StreamSender<T> {\n  /** Queue for side effects from requests */\n  private readonly requestScheduler = new Scheduler<() => SendState<T>>()\n\n  /** Queue for side effects from replies */\n  private readonly replyScheduler = new Scheduler<() => SendState<T>>()\n\n  /** Send an ILP Prepare over STREAM, then parse and authenticate the reply */\n  private readonly sendRequest: (request: StreamRequest) => Promise<StreamReply>\n\n  /** Order of STREAM controllers to iteratively build a request or cancel the attempt */\n  protected abstract readonly controllers: StreamController[]\n\n  /**\n   * Track completion criteria to finalize and send this request attempt,\n   * end the send loop, or re-schedule.\n   *\n   * Return state of the send loop:\n   * - `SendState.Send`     -- to send the request, applying side effects through all controllers in order,\n   * - `SendState.Done`     -- to resolve the send loop as successful,\n   * - `SendState.Error`    -- to end send loop with an error,\n   * - `SendState.Schedule` -- to cancel this request attempt and try again at a later time,\n   * - `SendState.Yield`    -- to cancel this request attempt and not directly schedule another.\n   *\n   * @param request Proposed ILP Prepare and STREAM request\n   * @param lookup Lookup or create an instance of another controller. Each connection instantiates a single controller per constructor\n   */\n  protected abstract nextState(request: RequestBuilder): SendState<T>\n\n  /** Logger namespaced to this connection */\n  readonly log: Logger\n\n  constructor(plugin: Plugin, destinationDetails: PaymentDestination) {\n    const { destinationAddress, sharedSecret } = destinationDetails\n\n    const connectionId = sha256(Buffer.from(destinationAddress)).toString('hex').slice(0, 6)\n    this.log = createLogger(`ilp-pay:${connectionId}`)\n\n    this.sendRequest = generateKeys(plugin, sharedSecret)\n  }\n\n  private trySending(): SendState<T> {\n    const request = new RequestBuilder({ log: this.log })\n    const requestState = [...this.controllers.values()].reduce<RequestState>(\n      (state, controller) =>\n        state.type === SendStateType.Ready ? controller.buildRequest?.(request) ?? state : state,\n      RequestState.Ready()\n    )\n    if (requestState.type !== SendStateType.Ready) {\n      return requestState // Cancel this attempt\n    }\n\n    // If committing and sending this request, continue\n    const state = this.nextState(request)\n    if (state.type !== SendStateType.Send) {\n      return state // Cancel this attempt\n    }\n\n    // Synchronously apply the request\n    const replyHandlers = this.controllers.map((c) => c.applyRequest?.(request))\n\n    // Asynchronously send the request and queue the reply side effects as another task\n    const task = this.sendRequest(request).then((reply) => () => {\n      // Apply side effects from all controllers and StreamSender, then return the first error or next state\n      // (For example, even if a payment error occurs in a controller, it shouldn't return\n      //  immediately since that packet still needs to be correctly accounted for)\n      const error = replyHandlers.map((apply) => apply?.(reply)).find(isPaymentError)\n      const newState = state.applyReply(reply)\n      return error ? SendState.Error(error) : newState\n    })\n\n    this.replyScheduler.queue(task)\n\n    return SendState.Schedule() // Schedule another attempt immediately\n  }\n\n  /**\n   * Send a series of requests, initiated by the given STREAM sender,\n   * until it completes its send loop or a payment error is encountered.\n   *\n   * Only one send loop can run at a time. A STREAM connection\n   * may run successive send loops for different functions or phases.\n   */\n  async start(): Promise<T | PaymentError> {\n    // Queue initial attempt to send a request\n    this.requestScheduler.queue(Promise.resolve(this.trySending.bind(this)))\n\n    for (;;) {\n      const applyEffects = await Promise.race([\n        this.replyScheduler.next(),\n        this.requestScheduler.next(),\n      ])\n      const state = applyEffects()\n\n      switch (state.type) {\n        case SendStateType.Done:\n        case SendStateType.Error:\n          await this.replyScheduler.complete() // Wait to process outstanding requests\n          return state.value\n\n        case SendStateType.Schedule:\n          this.requestScheduler.queue(state.delay.then(() => this.trySending.bind(this)))\n      }\n    }\n  }\n}\n\n/**\n * Task scheduler: a supercharged `Promise.race`.\n *\n * Queue \"tasks\", which are Promises resolving with a function. The scheduler aggregates\n * all pending tasks, where `next()` resolves to the task which resolves first. Critically,\n * this also *includes any tasks also queued while awaiting the aggregate Promise*.\n * Then, executing the resolved function removes the task, so the remaining\n * pending tasks can also be aggregated and awaited.\n */\nclass Scheduler<T extends (...args: any[]) => any> {\n  /** Set of tasks yet to be executed */\n  private pendingTasks = new Set<Promise<T>>()\n\n  /**\n   * Resolves to the task of the first event to resolve.\n   * Replaced with a new tick each time a task is executed\n   */\n  private nextTick = new PromiseResolver<T>()\n\n  /**\n   * Resolve to the pending task which resolves first, including existing tasks\n   * and any added after this is called.\n   */\n  next(): Promise<T> {\n    this.nextTick = new PromiseResolver<T>()\n    this.pendingTasks.forEach((task) => {\n      this.resolveTick(task)\n    })\n\n    return this.nextTick.promise\n  }\n\n  /**\n   * Execute all pending tasks immediately when they resolve,\n   * then resolve after all have resolved.\n   */\n  async complete(): Promise<any> {\n    return Promise.all([...this.pendingTasks].map((promise) => promise.then((run) => run())))\n  }\n\n  /** Schedule a task, which is Promise resolving to a function to execute */\n  queue(task: Promise<T>): void {\n    this.pendingTasks.add(task)\n    this.resolveTick(task)\n  }\n\n  /**\n   * Resolve the current tick when the given task resolves. Wrap\n   * the task's function to remove it as pending if it's executed.\n   */\n  private async resolveTick(task: Promise<T>): Promise<void> {\n    const run = await task\n    this.nextTick.resolve(<T>((...args: Parameters<T>): ReturnType<T> => {\n      this.pendingTasks.delete(task)\n      return run(...args)\n    }))\n  }\n}\n\n/** Promise that can be resolved or rejected outside its executor callback. */\nclass PromiseResolver<T> {\n  resolve!: (value: T) => void\n  reject!: () => void\n  readonly promise = new Promise<T>((resolve, reject) => {\n    this.resolve = resolve\n    this.reject = reject\n  })\n}\n"]}