{"version":3,"file":"open-payments.js","sourceRoot":"","sources":["../../src/open-payments.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/no-empty-function */\nimport { Int, isNonNegativeRational, sleep } from './utils'\nimport fetch, { Response } from 'node-fetch'\nimport { PaymentError, SetupOptions } from '.'\nimport createLogger from 'ilp-logger'\nimport { AssetDetails, isValidAssetScale, isValidAssetDetails } from './controllers/asset-details'\nimport { IlpAddress, isValidIlpAddress } from 'ilp-packet'\nimport AbortController from 'abort-controller'\nimport { AccountUrl, createHttpUrl } from './payment-pointer'\n\nconst SHARED_SECRET_BYTE_LENGTH = 32\nconst OPEN_PAYMENT_QUERY_ACCEPT_HEADER = 'application/json'\nconst ACCOUNT_QUERY_ACCEPT_HEADER = `${OPEN_PAYMENT_QUERY_ACCEPT_HEADER}, application/spsp4+json`\n\nconst log = createLogger('ilp-pay:query')\n\n/**\n * Destination details of the payment, such the asset, Incoming Payment, and STREAM credentials to\n * establish an authenticated connection with the receiver\n */\nexport interface PaymentDestination {\n  /** 32-byte seed to derive keys to encrypt STREAM messages and generate ILP packet fulfillments */\n  sharedSecret: Buffer\n  /** ILP address of the recipient, identifying this connection, which is used to send packets to their STREAM server */\n  destinationAddress: IlpAddress\n  /** Asset and denomination of the receiver's Interledger account */\n  destinationAsset?: AssetDetails\n  /** Open Payments Incoming Payment metadata, if the payment pays into an Incoming Payment */\n  destinationPaymentDetails?: IncomingPayment\n  /**\n   * URL of the recipient Open Payments/SPSP account (with well-known path, and stripped trailing slash).\n   * Each payment pointer and its corresponding account URL identifies a unique payment recipient.\n   * Not applicable if STREAM credentials were provided directly.\n   */\n  accountUrl?: string\n  /**\n   * Payment pointer, prefixed with \"$\", corresponding to the recipient Open Payments/SPSP account.\n   * Each payment pointer and its corresponding account URL identifies a unique payment recipient.\n   * Not applicable if STREAM credentials were provided directly.\n   */\n  destinationAccount?: string\n}\n\n/** [Open Payments Account](https://docs.openpayments.guide) metadata */\nexport interface Account {\n  /** URL identifying the Account */\n  id: string\n  /** A public name for the account */\n  publicName: string\n  /** Asset code or symbol identifying the currency of the account */\n  assetCode: string\n  /** Precision of the asset denomination: number of decimal places of the normal unit */\n  assetScale: number\n  /** The URL of the authorization server endpoint for getting grants and access tokens for this account **/\n  authServer: string\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\nconst isAccount = (o: any): o is Account => !!validateOpenPaymentsAccount(o)\n\n/** [Open Payments Incoming Payment](https://docs.openpayments.guide) metadata */\nexport interface IncomingPayment {\n  /** URL identifying the Incoming Payment */\n  id: string\n  /** URL identifying the account into which payments toward the Incoming Payment will be credited */\n  paymentPointer: string\n  /** Describes whether the Incoming Payment has completed receiving funds */\n  completed: boolean\n  /** UNIX timestamp in milliseconds when payments toward the Incoming Payment will no longer be accepted */\n  expiresAt?: number\n  /** Human-readable description of the Incoming Payment */\n  description?: string\n  /** Human-readable external reference of the Incoming Payment */\n  externalRef?: string\n  /** Fixed destination amount that must be delivered to complete payment of the Incoming Payment. */\n  incomingAmount?: Amount\n  /** Amount that has already been paid toward the Incoming Payment. */\n  receivedAmount: Amount\n}\n\nexport interface Amount {\n  // Amount, in base units. â‰¥0\n  value: bigint\n  /** Asset code or symbol identifying the currency of the account */\n  assetCode: string\n  /** Precision of the asset denomination: number of decimal places of the normal unit */\n  assetScale: number\n}\n\n/** Validate and resolve the details provided by recipient to execute the payment */\nexport const fetchPaymentDetails = async (\n  options: Partial<SetupOptions>\n): Promise<PaymentDestination | PaymentError> => {\n  const {\n    destinationPayment,\n    destinationConnection,\n    destinationAccount,\n    sharedSecret,\n    destinationAddress,\n    destinationAsset,\n  } = options\n\n  // Check that only one of destinationPayment, destinationConnection, destinationAccount, or STREAM credentials are provided\n  if (\n    Object.values({\n      destinationPayment,\n      destinationConnection,\n      destinationAccount,\n      destinationAddress,\n    }).filter((e) => e !== undefined).length > 1\n  ) {\n    log.debug(\n      'invalid config: more that one of destinationPayment, destinationConnection, destinationAccount, or STREAM credentials provided'\n    )\n    return PaymentError.InvalidDestination\n  }\n\n  // Resolve Incoming Payment and STREAM credentials\n  if (destinationPayment) {\n    return queryIncomingPayment(destinationPayment)\n  }\n  // Resolve STREAM credentials from Open Payments Connection URL\n  else if (destinationConnection) {\n    return queryConnection(destinationConnection)\n  }\n  // Resolve STREAM credentials from SPSP query at payment pointer\n  else if (destinationAccount) {\n    const account = await queryAccount(destinationAccount)\n    if (isAccount(account)) {\n      return PaymentError.InvalidDestination\n    } else {\n      return account\n    }\n  }\n  // STREAM credentials were provided directly\n  else if (\n    isSharedSecretBuffer(sharedSecret) &&\n    isValidIlpAddress(destinationAddress) &&\n    (!destinationAsset || isValidAssetDetails(destinationAsset))\n  ) {\n    log.warn(\n      'using custom STREAM credentials. destinationPayment or destinationAccount are recommended to setup a STREAM payment'\n    )\n    return {\n      sharedSecret,\n      destinationAddress,\n      destinationAsset,\n    }\n  }\n  // No STREAM credentials or method to resolve them\n  else {\n    log.debug(\n      'invalid config: no destinationPayment, destinationConnection, destinationAccount, or STREAM credentials provided'\n    )\n    return PaymentError.InvalidCredentials\n  }\n}\n\n/** Fetch an Incoming Payment and STREAM credentials from an Open Payments account */\nconst queryIncomingPayment = async (url: string): Promise<PaymentDestination | PaymentError> => {\n  if (!createHttpUrl(url)) {\n    log.debug('destinationPayment query failed: URL not HTTP/HTTPS.')\n    return PaymentError.QueryFailed\n  }\n\n  return fetchJson(url, OPEN_PAYMENT_QUERY_ACCEPT_HEADER)\n    .then(async (data) => {\n      const credentials = await validateOpenPaymentsCredentials(data)\n      const incomingPayment = validateOpenPaymentsIncomingPayment(data)\n\n      if (incomingPayment && credentials) {\n        return {\n          accountUrl: incomingPayment.paymentPointer,\n          destinationPaymentDetails: incomingPayment,\n          ...credentials,\n        }\n      }\n      log.debug('destinationPayment query returned an invalid response.')\n    })\n    .catch((err) => log.debug('destinationPayment query failed: %s', err?.message))\n    .then((res) => res || PaymentError.QueryFailed)\n}\n\n/** Query the payment pointer, Open Payments server, or SPSP server for credentials to establish a STREAM connection */\nexport const queryAccount = async (\n  destinationAccount: string\n): Promise<Account | PaymentDestination | PaymentError> => {\n  const accountUrl =\n    AccountUrl.fromPaymentPointer(destinationAccount) ?? AccountUrl.fromUrl(destinationAccount)\n  if (!accountUrl) {\n    log.debug('payment pointer or account url is invalid: %s', destinationAccount)\n    return PaymentError.InvalidPaymentPointer\n  }\n\n  return fetchJson(accountUrl.toEndpointUrl(), ACCOUNT_QUERY_ACCEPT_HEADER)\n    .then(\n      (data) =>\n        validateOpenPaymentsAccount(data) ??\n        validateSpspCredentials(data) ??\n        log.debug('payment pointer query returned no valid STREAM credentials.')\n    )\n    .catch((err) => log.debug('payment pointer query failed: %s', err))\n    .then((res) =>\n      res\n        ? isAccount(res)\n          ? res\n          : {\n              ...res,\n              accountUrl: accountUrl.toString(),\n              destinationAccount: accountUrl.toPaymentPointer(),\n            }\n        : PaymentError.QueryFailed\n    )\n}\n\n/** Query an Open Payments Connection endpoint for STREAM credentials*/\nconst queryConnection = async (url: string): Promise<PaymentDestination | PaymentError> => {\n  if (!createHttpUrl(url)) {\n    log.debug('destinationPayment query failed: URL not HTTP/HTTPS.')\n    return PaymentError.QueryFailed\n  }\n  return fetchJson(url, OPEN_PAYMENT_QUERY_ACCEPT_HEADER)\n    .then(\n      (data) =>\n        validateConnectionCredentials(data) ??\n        log.debug('payment pointer query returned no valid STREAM credentials.')\n    )\n    .catch((err) => log.debug('payment pointer query failed: %s', err))\n    .then((res) => (res ? res : PaymentError.QueryFailed))\n}\n\n/** Perform an HTTP request using `fetch` with timeout and retries. Resolve with parsed JSON, reject otherwise. */\nconst fetchJson = async (\n  url: string,\n  acceptHeader: string,\n  timeout = 3000,\n  remainingRetries = [10, 500, 2500] // Retry up to 3 times with increasing backoff\n): Promise<any> => {\n  const controller = new AbortController()\n  const timer = setTimeout(() => controller.abort(), timeout)\n\n  const retryDelay = remainingRetries.shift()\n\n  return fetch(url, {\n    redirect: 'follow',\n    headers: {\n      Accept: acceptHeader,\n    },\n    signal: controller.signal,\n  })\n    .then(\n      async (res: Response) => {\n        // If server error, retry after delay\n        if ((res.status >= 500 || res.status === 429) && retryDelay) {\n          await sleep(retryDelay)\n          return fetchJson(url, acceptHeader, timeout, remainingRetries)\n        }\n\n        // Parse JSON on HTTP 2xx, otherwise error\n        return res.ok ? res.json() : Promise.reject()\n      },\n      async (err: Error) => {\n        // Only handle timeout (abort) errors. Use two `then` callbacks instead\n        // of then/catch so JSON parsing errors, etc. are not caught here.\n        if (err.name !== 'AbortError' && retryDelay) {\n          await sleep(retryDelay)\n          return fetchJson(url, acceptHeader, timeout, remainingRetries)\n        }\n\n        throw err\n      }\n    )\n    .finally(() => clearTimeout(timer))\n}\n\nconst validateSharedSecretBase64 = (o: any): Buffer | undefined => {\n  if (typeof o === 'string') {\n    const sharedSecret = Buffer.from(o, 'base64')\n    if (sharedSecret.byteLength === SHARED_SECRET_BYTE_LENGTH) {\n      return sharedSecret\n    }\n  }\n}\n\nconst isSharedSecretBuffer = (o: any): o is Buffer =>\n  Buffer.isBuffer(o) && o.byteLength === SHARED_SECRET_BYTE_LENGTH\n\n/** Validate the input is a number or string in the range of a u64 integer, and transform into `Int` */\nconst validateUInt64 = (o: any): Int | undefined => {\n  if (!['string', 'number'].includes(typeof o)) {\n    return\n  }\n\n  const n = Int.from(o)\n  if (n?.isLessThanOrEqualTo(Int.MAX_U64)) {\n    return n\n  }\n}\n\nconst isNonNullObject = (o: any): o is Record<string, any> => typeof o === 'object' && o !== null\n\n/** Transform the Open Payments server response into a validated Account */\nconst validateOpenPaymentsAccount = (o: any): Account | undefined => {\n  if (!isNonNullObject(o)) {\n    return\n  }\n\n  const { id, publicName, assetCode, assetScale, authServer } = o\n\n  if (\n    typeof id !== 'string' ||\n    !(typeof publicName === 'string' || publicName === undefined) ||\n    typeof assetCode !== 'string' ||\n    !isValidAssetScale(assetScale) ||\n    typeof authServer !== 'string'\n  ) {\n    return\n  }\n\n  if (!AccountUrl.fromUrl(id)) return\n\n  // TODO Should the given Account URL be validated against the `id` URL in the Account itself?\n\n  return {\n    id,\n    publicName,\n    assetCode,\n    assetScale,\n    authServer,\n  }\n}\n\n/** Transform the Open Payments server response into a validated IncomingPayment */\nconst validateOpenPaymentsIncomingPayment = (\n  o: any,\n  expectedAmount?: Amount\n): IncomingPayment | undefined => {\n  if (!isNonNullObject(o)) {\n    return\n  }\n\n  const {\n    id,\n    paymentPointer,\n    completed,\n    incomingAmount: unvalidatedIncomingAmount,\n    receivedAmount: unvalidatedReceivedAmount,\n    expiresAt: expiresAtIso,\n    description,\n    externalRef,\n  } = o\n  const expiresAt = expiresAtIso ? Date.parse(expiresAtIso) : undefined // `NaN` if date is invalid\n  const incomingAmount = validateOpenPaymentsAmount(unvalidatedIncomingAmount)\n  const receivedAmount = validateOpenPaymentsAmount(unvalidatedReceivedAmount)\n\n  if (\n    typeof id !== 'string' ||\n    typeof paymentPointer !== 'string' ||\n    typeof completed !== 'boolean' ||\n    !(typeof description === 'string' || description === undefined) ||\n    !(typeof externalRef === 'string' || externalRef === undefined) ||\n    !(isNonNegativeRational(expiresAt) || expiresAt === undefined) ||\n    incomingAmount === null ||\n    !receivedAmount\n  ) {\n    return\n  }\n\n  if (expectedAmount) {\n    if (\n      incomingAmount?.value !== expectedAmount.value ||\n      incomingAmount?.assetCode !== expectedAmount.assetCode ||\n      incomingAmount?.assetScale !== expectedAmount.assetScale\n    ) {\n      return\n    }\n  }\n\n  if (!AccountUrl.fromUrl(id)) return\n  if (!AccountUrl.fromUrl(paymentPointer)) return\n\n  // TODO Should the given Incoming Payment URL be validated against the `id` URL in the Incoming Payment itself?\n\n  return {\n    id,\n    paymentPointer,\n    completed,\n    expiresAt,\n    description,\n    externalRef,\n    receivedAmount,\n    incomingAmount,\n  }\n}\n\n/** Validate Open Payments STREAM credentials and asset details */\nconst validateOpenPaymentsCredentials = async (o: any): Promise<PaymentDestination | undefined> => {\n  if (!isNonNullObject(o)) {\n    return\n  }\n\n  const { ilpStreamConnection, receivedAmount } = o\n  if (!receivedAmount) return\n  let details\n  if (typeof ilpStreamConnection === 'string') {\n    details = await fetchJson(ilpStreamConnection, OPEN_PAYMENT_QUERY_ACCEPT_HEADER)\n  } else {\n    details = ilpStreamConnection\n  }\n  const { ilpAddress: destinationAddress, sharedSecret: sharedSecretBase64 } = details\n  const sharedSecret = validateSharedSecretBase64(sharedSecretBase64)\n  const destinationAmount = validateOpenPaymentsAmount(receivedAmount)\n  if (!sharedSecret || !isValidIlpAddress(destinationAddress) || !destinationAmount) {\n    return\n  }\n\n  return {\n    destinationAsset: { code: destinationAmount.assetCode, scale: destinationAmount.assetScale },\n    destinationAddress,\n    sharedSecret,\n  }\n}\n\n/** Validate and transform the SPSP server response into STREAM credentials */\nconst validateSpspCredentials = (o: any): PaymentDestination | undefined => {\n  if (!isNonNullObject(o)) {\n    return\n  }\n\n  const { destination_account: destinationAddress, shared_secret } = o\n  const sharedSecret = validateSharedSecretBase64(shared_secret)\n  if (sharedSecret && isValidIlpAddress(destinationAddress)) {\n    return { destinationAddress, sharedSecret }\n  }\n}\n\n/** Validate and transform the Open Payments connection endpoint response into STREAM credentials */\nconst validateConnectionCredentials = (o: any): PaymentDestination | undefined => {\n  if (!isNonNullObject(o)) {\n    return\n  }\n\n  const { ilpAddress: destinationAddress, sharedSecret: sharedSecretBase64 } = o\n  const sharedSecret = validateSharedSecretBase64(sharedSecretBase64)\n  if (sharedSecret && isValidIlpAddress(destinationAddress)) {\n    return { destinationAddress, sharedSecret }\n  }\n}\n\nconst validateOpenPaymentsAmount = (o: Record<string, any>): Amount | undefined | null => {\n  if (o === undefined) return undefined\n  const { value, assetScale, assetCode } = o\n  const amountInt = validateUInt64(value)\n  if (amountInt && isValidAssetScale(assetScale) && typeof assetCode === 'string') {\n    return { value: amountInt.value, assetCode, assetScale }\n  } else {\n    return null\n  }\n}\n"]}