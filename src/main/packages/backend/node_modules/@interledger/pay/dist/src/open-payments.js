"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.queryAccount = exports.fetchPaymentDetails = void 0;
const utils_1 = require("@interledger/pay/dist/src/utils");
const node_fetch_1 = __importDefault(require("node-fetch"));
const _1 = require("@interledger/pay");
const ilp_logger_1 = __importDefault(require("ilp-logger"));
const asset_details_1 = require("@interledger/pay/dist/src/controllers/asset-details");
const ilp_packet_1 = require("ilp-packet");
const abort_controller_1 = __importDefault(require("abort-controller"));
const payment_pointer_1 = require("@interledger/pay/dist/src/payment-pointer");
const SHARED_SECRET_BYTE_LENGTH = 32;
const OPEN_PAYMENT_QUERY_ACCEPT_HEADER = 'application/json';
const ACCOUNT_QUERY_ACCEPT_HEADER = `${OPEN_PAYMENT_QUERY_ACCEPT_HEADER}, application/spsp4+json`;
const log = (0, ilp_logger_1.default)('ilp-pay:query');
const isAccount = (o) => !!validateOpenPaymentsAccount(o);
const fetchPaymentDetails = async (options) => {
    const { destinationPayment, destinationConnection, destinationAccount, sharedSecret, destinationAddress, destinationAsset, } = options;
    if (Object.values({
        destinationPayment,
        destinationConnection,
        destinationAccount,
        destinationAddress,
    }).filter((e) => e !== undefined).length > 1) {
        log.debug('invalid config: more that one of destinationPayment, destinationConnection, destinationAccount, or STREAM credentials provided');
        return _1.PaymentError.InvalidDestination;
    }
    if (destinationPayment) {
        return queryIncomingPayment(destinationPayment);
    }
    else if (destinationConnection) {
        return queryConnection(destinationConnection);
    }
    else if (destinationAccount) {
        const account = await (0, exports.queryAccount)(destinationAccount);
        if (isAccount(account)) {
            return _1.PaymentError.InvalidDestination;
        }
        else {
            return account;
        }
    }
    else if (isSharedSecretBuffer(sharedSecret) &&
        (0, ilp_packet_1.isValidIlpAddress)(destinationAddress) &&
        (!destinationAsset || (0, asset_details_1.isValidAssetDetails)(destinationAsset))) {
        log.warn('using custom STREAM credentials. destinationPayment or destinationAccount are recommended to setup a STREAM payment');
        return {
            sharedSecret,
            destinationAddress,
            destinationAsset,
        };
    }
    else {
        log.debug('invalid config: no destinationPayment, destinationConnection, destinationAccount, or STREAM credentials provided');
        return _1.PaymentError.InvalidCredentials;
    }
};
exports.fetchPaymentDetails = fetchPaymentDetails;
const queryIncomingPayment = async (url) => {
    if (!(0, payment_pointer_1.createHttpUrl)(url)) {
        log.debug('destinationPayment query failed: URL not HTTP/HTTPS.');
        return _1.PaymentError.QueryFailed;
    }
    return fetchJson(url, OPEN_PAYMENT_QUERY_ACCEPT_HEADER)
        .then(async (data) => {
        const credentials = await validateOpenPaymentsCredentials(data);
        const incomingPayment = validateOpenPaymentsIncomingPayment(data);
        if (incomingPayment && credentials) {
            return {
                accountUrl: incomingPayment.paymentPointer,
                destinationPaymentDetails: incomingPayment,
                ...credentials,
            };
        }
        log.debug('destinationPayment query returned an invalid response.');
    })
        .catch((err) => log.debug('destinationPayment query failed: %s', err === null || err === void 0 ? void 0 : err.message))
        .then((res) => res || _1.PaymentError.QueryFailed);
};
const queryAccount = async (destinationAccount) => {
    var _a;
    const accountUrl = (_a = payment_pointer_1.AccountUrl.fromPaymentPointer(destinationAccount)) !== null && _a !== void 0 ? _a : payment_pointer_1.AccountUrl.fromUrl(destinationAccount);
    if (!accountUrl) {
        log.debug('payment pointer or account url is invalid: %s', destinationAccount);
        return _1.PaymentError.InvalidPaymentPointer;
    }
    return fetchJson(accountUrl.toEndpointUrl(), ACCOUNT_QUERY_ACCEPT_HEADER)
        .then((data) => {
        var _a, _b;
        return (_b = (_a = validateOpenPaymentsAccount(data)) !== null && _a !== void 0 ? _a : validateSpspCredentials(data)) !== null && _b !== void 0 ? _b : log.debug('payment pointer query returned no valid STREAM credentials.');
    })
        .catch((err) => log.debug('payment pointer query failed: %s', err))
        .then((res) => res
        ? isAccount(res)
            ? res
            : {
                ...res,
                accountUrl: accountUrl.toString(),
                destinationAccount: accountUrl.toPaymentPointer(),
            }
        : _1.PaymentError.QueryFailed);
};
exports.queryAccount = queryAccount;
const queryConnection = async (url) => {
    if (!(0, payment_pointer_1.createHttpUrl)(url)) {
        log.debug('destinationPayment query failed: URL not HTTP/HTTPS.');
        return _1.PaymentError.QueryFailed;
    }
    return fetchJson(url, OPEN_PAYMENT_QUERY_ACCEPT_HEADER)
        .then((data) => {
        var _a;
        return (_a = validateConnectionCredentials(data)) !== null && _a !== void 0 ? _a : log.debug('payment pointer query returned no valid STREAM credentials.');
    })
        .catch((err) => log.debug('payment pointer query failed: %s', err))
        .then((res) => (res ? res : _1.PaymentError.QueryFailed));
};
const fetchJson = async (url, acceptHeader, timeout = 3000, remainingRetries = [10, 500, 2500]) => {
    const controller = new abort_controller_1.default();
    const timer = setTimeout(() => controller.abort(), timeout);
    const retryDelay = remainingRetries.shift();
    return (0, node_fetch_1.default)(url, {
        redirect: 'follow',
        headers: {
            Accept: acceptHeader,
        },
        signal: controller.signal,
    })
        .then(async (res) => {
        if ((res.status >= 500 || res.status === 429) && retryDelay) {
            await (0, utils_1.sleep)(retryDelay);
            return fetchJson(url, acceptHeader, timeout, remainingRetries);
        }
        return res.ok ? res.json() : Promise.reject();
    }, async (err) => {
        if (err.name !== 'AbortError' && retryDelay) {
            await (0, utils_1.sleep)(retryDelay);
            return fetchJson(url, acceptHeader, timeout, remainingRetries);
        }
        throw err;
    })
        .finally(() => clearTimeout(timer));
};
const validateSharedSecretBase64 = (o) => {
    if (typeof o === 'string') {
        const sharedSecret = Buffer.from(o, 'base64');
        if (sharedSecret.byteLength === SHARED_SECRET_BYTE_LENGTH) {
            return sharedSecret;
        }
    }
};
const isSharedSecretBuffer = (o) => Buffer.isBuffer(o) && o.byteLength === SHARED_SECRET_BYTE_LENGTH;
const validateUInt64 = (o) => {
    if (!['string', 'number'].includes(typeof o)) {
        return;
    }
    const n = utils_1.Int.from(o);
    if (n === null || n === void 0 ? void 0 : n.isLessThanOrEqualTo(utils_1.Int.MAX_U64)) {
        return n;
    }
};
const isNonNullObject = (o) => typeof o === 'object' && o !== null;
const validateOpenPaymentsAccount = (o) => {
    if (!isNonNullObject(o)) {
        return;
    }
    const { id, publicName, assetCode, assetScale, authServer } = o;
    if (typeof id !== 'string' ||
        !(typeof publicName === 'string' || publicName === undefined) ||
        typeof assetCode !== 'string' ||
        !(0, asset_details_1.isValidAssetScale)(assetScale) ||
        typeof authServer !== 'string') {
        return;
    }
    if (!payment_pointer_1.AccountUrl.fromUrl(id))
        return;
    return {
        id,
        publicName,
        assetCode,
        assetScale,
        authServer,
    };
};
const validateOpenPaymentsIncomingPayment = (o, expectedAmount) => {
    if (!isNonNullObject(o)) {
        return;
    }
    const { id, paymentPointer, completed, incomingAmount: unvalidatedIncomingAmount, receivedAmount: unvalidatedReceivedAmount, expiresAt: expiresAtIso, description, externalRef, } = o;
    const expiresAt = expiresAtIso ? Date.parse(expiresAtIso) : undefined;
    const incomingAmount = validateOpenPaymentsAmount(unvalidatedIncomingAmount);
    const receivedAmount = validateOpenPaymentsAmount(unvalidatedReceivedAmount);
    if (typeof id !== 'string' ||
        typeof paymentPointer !== 'string' ||
        typeof completed !== 'boolean' ||
        !(typeof description === 'string' || description === undefined) ||
        !(typeof externalRef === 'string' || externalRef === undefined) ||
        !((0, utils_1.isNonNegativeRational)(expiresAt) || expiresAt === undefined) ||
        incomingAmount === null ||
        !receivedAmount) {
        return;
    }
    if (expectedAmount) {
        if ((incomingAmount === null || incomingAmount === void 0 ? void 0 : incomingAmount.value) !== expectedAmount.value ||
            (incomingAmount === null || incomingAmount === void 0 ? void 0 : incomingAmount.assetCode) !== expectedAmount.assetCode ||
            (incomingAmount === null || incomingAmount === void 0 ? void 0 : incomingAmount.assetScale) !== expectedAmount.assetScale) {
            return;
        }
    }
    if (!payment_pointer_1.AccountUrl.fromUrl(id))
        return;
    if (!payment_pointer_1.AccountUrl.fromUrl(paymentPointer))
        return;
    return {
        id,
        paymentPointer,
        completed,
        expiresAt,
        description,
        externalRef,
        receivedAmount,
        incomingAmount,
    };
};
const validateOpenPaymentsCredentials = async (o) => {
    if (!isNonNullObject(o)) {
        return;
    }
    const { ilpStreamConnection, receivedAmount } = o;
    if (!receivedAmount)
        return;
    let details;
    if (typeof ilpStreamConnection === 'string') {
        details = await fetchJson(ilpStreamConnection, OPEN_PAYMENT_QUERY_ACCEPT_HEADER);
    }
    else {
        details = ilpStreamConnection;
    }
    const { ilpAddress: destinationAddress, sharedSecret: sharedSecretBase64 } = details;
    const sharedSecret = validateSharedSecretBase64(sharedSecretBase64);
    const destinationAmount = validateOpenPaymentsAmount(receivedAmount);
    if (!sharedSecret || !(0, ilp_packet_1.isValidIlpAddress)(destinationAddress) || !destinationAmount) {
        return;
    }
    return {
        destinationAsset: { code: destinationAmount.assetCode, scale: destinationAmount.assetScale },
        destinationAddress,
        sharedSecret,
    };
};
const validateSpspCredentials = (o) => {
    if (!isNonNullObject(o)) {
        return;
    }
    const { destination_account: destinationAddress, shared_secret } = o;
    const sharedSecret = validateSharedSecretBase64(shared_secret);
    if (sharedSecret && (0, ilp_packet_1.isValidIlpAddress)(destinationAddress)) {
        return { destinationAddress, sharedSecret };
    }
};
const validateConnectionCredentials = (o) => {
    if (!isNonNullObject(o)) {
        return;
    }
    const { ilpAddress: destinationAddress, sharedSecret: sharedSecretBase64 } = o;
    const sharedSecret = validateSharedSecretBase64(sharedSecretBase64);
    if (sharedSecret && (0, ilp_packet_1.isValidIlpAddress)(destinationAddress)) {
        return { destinationAddress, sharedSecret };
    }
};
const validateOpenPaymentsAmount = (o) => {
    if (o === undefined)
        return undefined;
    const { value, assetScale, assetCode } = o;
    const amountInt = validateUInt64(value);
    if (amountInt && (0, asset_details_1.isValidAssetScale)(assetScale) && typeof assetCode === 'string') {
        return { value: amountInt.value, assetCode, assetScale };
    }
    else {
        return null;
    }
};
//# sourceMappingURL=open-payments.js.map