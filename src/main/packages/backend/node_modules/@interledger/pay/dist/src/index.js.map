{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { AssetDetails, isValidAssetDetails } from './controllers/asset-details'\nimport { Counter } from './controllers/sequence'\nimport { fetchPaymentDetails, PaymentDestination, Amount } from './open-payments'\nimport { Plugin } from './request'\nimport { AssetProbe } from './senders/asset-probe'\nimport { ConnectionCloser } from './senders/connection-closer'\nimport { PaymentSender, PaymentType } from './senders/payment'\nimport { RateProbe } from './senders/rate-probe'\nimport {\n  Int,\n  isNonNegativeRational,\n  NonNegativeRational,\n  PositiveInt,\n  PositiveRatio,\n  Ratio,\n} from './utils'\n\nexport { IncomingPayment } from './open-payments'\nexport { AccountUrl } from './payment-pointer'\nexport { Int, PositiveInt, PositiveRatio, Ratio, Counter, PaymentType, AssetDetails }\n\n/** Recipient-provided details to resolve payment parameters, and connected ILP uplink */\nexport interface SetupOptions {\n  /** Plugin to send ILP packets over the network */\n  plugin: Plugin\n  /** Payment pointer, Open Payments or SPSP account URL to query STREAM connection credentials */\n  destinationAccount?: string\n  /** Open Payments Incoming Payment URL to resolve details and credentials to pay a fixed-delivery payment */\n  destinationPayment?: string\n  /** Open Payments Connection URL to resolve STREAM connection credentials */\n  destinationConnection?: string\n  /** Fixed amount to deliver to the recipient, in base units of destination asset */\n  amountToDeliver?: Amount\n  /** For testing purposes: symmetric key to encrypt STREAM messages. Requires `destinationAddress` */\n  sharedSecret?: Uint8Array\n  /** For testing purposes: ILP address of the STREAM receiver to send outgoing packets. Requires `sharedSecret` */\n  destinationAddress?: string\n  /** For testing purposes: asset details of the STREAM recipient, overriding STREAM and Incoming Payment. Requires `destinationAddress` */\n  destinationAsset?: AssetDetails\n}\n\n/** Resolved destination details of a proposed payment, such as the destination asset, Incoming Payment, and STREAM credentials, ready to perform a quote */\nexport interface ResolvedPayment extends PaymentDestination {\n  /** Asset and denomination of the receiver's Interedger account */\n  destinationAsset: AssetDetails\n  /** Strict counter of how many packets have been sent, to safely resume a connection */\n  requestCounter: Counter\n}\n\n/** Limits and target to quote a payment and probe the rate */\nexport interface QuoteOptions {\n  /** Plugin to send ILP packets over the network */\n  plugin: Plugin\n  /** Resolved destination details of the payment to establish connection with recipient */\n  destination: ResolvedPayment\n  /** Asset and denomination of the sending account */\n  sourceAsset?: AssetDetails\n  /** Fixed amount to send to the recipient, in base units of source asset */\n  amountToSend?: Int | string | number | bigint\n  /** Fixed amount to deliver to the recipient, in base units of destination asset */\n  amountToDeliver?: Int | string | number | bigint\n  /** Percentage to subtract from an external exchange rate to determine the minimum acceptable exchange rate */\n  slippage?: number\n  /** Set of asset codes -> price in a standardized base asset, to compute minimum exchange rates */\n  prices?: {\n    [assetCode: string]: number\n  }\n}\n\n/** Parameters of payment execution and the projected outcome of a payment */\nexport interface Quote {\n  /** How payment completion is ascertained: fixed send amount or fixed delivery amount */\n  readonly paymentType: PaymentType\n  /** Maximum amount that will be sent in source units */\n  readonly maxSourceAmount: bigint\n  /** Minimum amount that will be delivered if the payment fully completes */\n  readonly minDeliveryAmount: bigint\n  /** Discovered maximum packet amount allowed over this payment path */\n  readonly maxPacketAmount: bigint\n  /** Lower bound of probed exchange rate over the path (inclusive). Ratio of destination base units to source base units */\n  readonly lowEstimatedExchangeRate: Ratio\n  /** Upper bound of probed exchange rate over the path (exclusive). Ratio of destination base units to source base units */\n  readonly highEstimatedExchangeRate: PositiveRatio\n  /** Minimum exchange rate used to enforce rates. Ratio of destination base units to source base units */\n  readonly minExchangeRate: Ratio\n}\n\n/** Quote with stricter types, for internal library use */\nexport type IntQuote = Omit<Quote, 'maxSourceAmount' | 'minDeliveryAmount' | 'maxPacketAmount'> & {\n  readonly maxSourceAmount: PositiveInt\n  readonly minDeliveryAmount: Int\n  readonly maxPacketAmount: PositiveInt\n}\n\n/** Options before immediately executing payment */\nexport interface PayOptions {\n  /** Plugin to send ILP packets over the network */\n  plugin: Plugin\n  /** Destination details of the payment to establish connection with recipient */\n  destination: ResolvedPayment\n  /** Parameters of payment execution */\n  quote: Quote\n  /**\n   * Callback to process streaming updates as packets are sent and received,\n   * such as to perform accounting while the payment is in progress.\n   *\n   * Handler will be called for all fulfillable packets and replies before the payment resolves.\n   */\n  progressHandler?: (progress: PaymentProgress) => void\n}\n\n/** Intermediate state or outcome of the payment, to account for sent/delivered amounts */\nexport interface PaymentProgress {\n  /** Error state, if payment failed */\n  error?: PaymentError\n  /** Amount sent and fulfilled, in base units of the source asset. ≥0 */\n  amountSent: bigint\n  /** Amount delivered to recipient, in base units of the destination asset. ≥0 */\n  amountDelivered: bigint\n  /** Amount sent that is yet to be fulfilled or rejected, in base units of the source asset. ≥0 */\n  sourceAmountInFlight: bigint\n  /** Estimate of the amount that may be delivered from in-flight packets, in base units of the destination asset. ≥0 */\n  destinationAmountInFlight: bigint\n  /** Latest [STREAM receipt](https://interledger.org/rfcs/0039-stream-receipts/) to provide proof-of-delivery to a 3rd party verifier */\n  streamReceipt?: Uint8Array\n}\n\n/** Payment error states */\nexport enum PaymentError {\n  /**\n   * Errors likely caused by the library user\n   */\n\n  /** Payment pointer or SPSP URL is syntactically invalid */\n  InvalidPaymentPointer = 'InvalidPaymentPointer',\n  /** STREAM credentials (shared secret and destination address) were not provided or invalid */\n  InvalidCredentials = 'InvalidCredentials',\n  /** Slippage percentage is not between 0 and 1 (inclusive) */\n  InvalidSlippage = 'InvalidSlippage',\n  /** Source asset or denomination was not provided */\n  UnknownSourceAsset = 'UnknownSourceAsset',\n  /** No fixed source amount or fixed destination amount was provided */\n  UnknownPaymentTarget = 'UnknownPaymentTarget',\n  /** Fixed source amount is invalid or too precise for the source account */\n  InvalidSourceAmount = 'InvalidSourceAmount',\n  /** Fixed delivery amount is invalid or too precise for the destination account */\n  InvalidDestinationAmount = 'InvalidDestinationAmount',\n  /** Minimum exchange rate is 0 after subtracting slippage and cannot enforce a fixed-delivery payment */\n  UnenforceableDelivery = 'UnenforceableDelivery',\n  /** Invalid quote parameters provided */\n  InvalidQuote = 'InvalidQuote',\n  /** Invalid destination like an Open Payments account URL provided */\n  InvalidDestination = 'InvalidDestination',\n\n  /**\n   * Errors likely caused by the receiver, connectors, or other externalities\n   */\n\n  /** Failed to query an account or Incoming Payment from an Open Payments or SPSP server */\n  QueryFailed = 'QueryFailed',\n  /** Incoming payment was already completed */\n  IncomingPaymentCompleted = 'IncomingPaymentCompleted',\n  /** Incoming payment already expired */\n  IncomingPaymentExpired = 'IncomingPaymentExpired',\n  /** Cannot send over this path due to an ILP Reject error */\n  ConnectorError = 'ConnectorError',\n  /** No authentic reply from receiver: packets may not have been delivered */\n  EstablishmentFailed = 'EstablishmentFailed',\n  /** Destination asset details are unknown or the receiver never provided them */\n  UnknownDestinationAsset = 'UnknownDestinationAsset',\n  /** Receiver sent conflicting destination asset details */\n  DestinationAssetConflict = 'DestinationAssetConflict',\n  /** Failed to compute minimum rate: prices for source or destination assets were invalid or not provided */\n  ExternalRateUnavailable = 'ExternalRateUnavailable',\n  /** Rate probe failed to establish the exchange rate or discover path max packet amount */\n  RateProbeFailed = 'RateProbeFailed',\n  /** Real exchange rate is less than minimum exchange rate with slippage */\n  InsufficientExchangeRate = 'InsufficientExchangeRate',\n  /** No packets were fulfilled within timeout */\n  IdleTimeout = 'IdleTimeout',\n  /** Receiver closed the connection or stream, terminating the payment */\n  ClosedByReceiver = 'ClosedByReceiver',\n  /** Estimated destination amount exceeds the receiver's limit */\n  IncompatibleReceiveMax = 'IncompatibleReceiveMax',\n  /** Receiver violated the STREAM protocol, misrepresenting delivered amounts */\n  ReceiverProtocolViolation = 'ReceiverProtocolViolation',\n  /** Encrypted maximum number of packets using the key for this connection */\n  MaxSafeEncryptionLimit = 'MaxSafeEncryptionLimit',\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\nexport const isPaymentError = (o: any): o is PaymentError => Object.values(PaymentError).includes(o)\n\n/** Resolve destination details and asset of the payment in order to establish a STREAM connection */\nexport const setupPayment = async (options: SetupOptions): Promise<ResolvedPayment> => {\n  // Determine STREAM credentials, amount to pay, and destination details\n  // by performing Open Payments/SPSP queries, or using the provided info\n  const destinationDetailsOrError = await fetchPaymentDetails(options)\n  if (isPaymentError(destinationDetailsOrError)) {\n    throw destinationDetailsOrError\n  }\n  const destinationDetails = destinationDetailsOrError\n\n  // Use STREAM to fetch the destination asset (returns immediately if asset is already known)\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  const requestCounter = Counter.from(0)!\n  const assetOrError = await new AssetProbe(\n    options.plugin,\n    destinationDetails,\n    requestCounter\n  ).start()\n  if (isPaymentError(assetOrError)) {\n    throw assetOrError\n  }\n  const destinationAsset = assetOrError\n\n  return {\n    ...destinationDetails,\n    destinationAsset,\n    requestCounter,\n  }\n}\n\n/** Perform a rate probe: discover path max packet amount, probe the real exchange rate, and compute the minimum exchange rate and bounds of the payment. */\nexport const startQuote = async (options: QuoteOptions): Promise<Quote> => {\n  const rateProbe = new RateProbe(options)\n  const { log } = rateProbe\n  const { destinationPaymentDetails, destinationAsset } = options.destination\n\n  if (destinationPaymentDetails) {\n    if (destinationPaymentDetails.completed) {\n      log.debug('quote failed: Incoming Payment is already completed.')\n      // In Incoming Payment case, STREAM connection is yet to be established since no asset probe\n      throw PaymentError.IncomingPaymentCompleted\n    }\n    if (destinationPaymentDetails.expiresAt && destinationPaymentDetails.expiresAt <= Date.now()) {\n      log.debug('quote failed: Incoming Payment is expired.')\n      // In Incoming Payment case, STREAM connection is yet to be established since no asset probe\n      throw PaymentError.IncomingPaymentExpired\n    }\n  }\n\n  // Validate the amounts to set the target for the payment\n  let target: {\n    type: PaymentType\n    amount: PositiveInt\n  }\n\n  if (\n    destinationPaymentDetails &&\n    typeof destinationPaymentDetails.incomingAmount !== 'undefined'\n  ) {\n    const remainingToDeliver = Int.from(\n      destinationPaymentDetails.incomingAmount.value -\n        destinationPaymentDetails.receivedAmount.value\n    )\n    if (!remainingToDeliver || !remainingToDeliver.isPositive()) {\n      // Return this error here instead of in `setupPayment` so consumer can access the resolved Incoming Payment\n      log.debug(\n        'quote failed: Incoming Payment was already paid. incomingAmount=%s receivedAmount=%s',\n        destinationPaymentDetails.incomingAmount,\n        destinationPaymentDetails.receivedAmount\n      )\n      // In Incoming Payment case, STREAM connection is yet to be established since no asset probe\n      throw PaymentError.IncomingPaymentCompleted\n    }\n\n    target = {\n      type: PaymentType.FixedDelivery,\n      amount: remainingToDeliver,\n    }\n  } else if (typeof options.amountToDeliver !== 'undefined') {\n    const amountToDeliver = Int.from(options.amountToDeliver)\n    if (!amountToDeliver || !amountToDeliver.isPositive()) {\n      log.debug('invalid config: amount to deliver is not a positive integer')\n      throw PaymentError.InvalidDestinationAmount\n    }\n\n    target = {\n      type: PaymentType.FixedDelivery,\n      amount: amountToDeliver,\n    }\n  }\n  // Validate the target amount is non-zero and compatible with the precision of the accounts\n  else if (typeof options.amountToSend !== 'undefined') {\n    const amountToSend = Int.from(options.amountToSend)\n    if (!amountToSend || !amountToSend.isPositive()) {\n      log.debug('invalid config: amount to send is not a positive integer')\n      throw PaymentError.InvalidSourceAmount\n    }\n\n    target = {\n      type: PaymentType.FixedSend,\n      amount: amountToSend,\n    }\n  } else {\n    log.debug(\n      'invalid config: no Incoming Payment with existing incomingAmount, amount to send, or amount to deliver was provided'\n    )\n    throw PaymentError.UnknownPaymentTarget\n  }\n\n  // Validate the slippage\n  const slippage = options.slippage ?? 0.01\n  if (!isNonNegativeRational(slippage) || slippage > 1) {\n    log.debug('invalid config: slippage is not a number between 0 and 1')\n    throw PaymentError.InvalidSlippage\n  }\n\n  // No source asset or minimum rate computation if 100% slippage\n  let externalRate: number\n  if (slippage === 1) {\n    externalRate = 0\n  } else {\n    // Validate source asset details\n    const { sourceAsset } = options\n    if (!isValidAssetDetails(sourceAsset)) {\n      log.debug('invalid config: no source asset details were provided')\n      throw PaymentError.UnknownSourceAsset\n    }\n\n    // Compute minimum exchange rate, or 1:1 if assets are the same.\n    if (sourceAsset.code === destinationAsset.code) {\n      externalRate = 1\n    } else {\n      const sourcePrice = options.prices?.[sourceAsset.code]\n      const destinationPrice = options.prices?.[destinationAsset.code]\n\n      // Ensure the prices are defined, finite, and denominator > 0\n      if (\n        !isNonNegativeRational(sourcePrice) ||\n        !isNonNegativeRational(destinationPrice) ||\n        destinationPrice === 0\n      ) {\n        log.debug(\n          'quote failed: no external rate available from %s to %s',\n          sourceAsset.code,\n          destinationAsset.code\n        )\n        throw PaymentError.ExternalRateUnavailable\n      }\n\n      // This seems counterintuitive because rates are destination amount / source amount,\n      // but each price *is a rate*, not an amount.\n      // For example: sourcePrice => USD/ABC, destPrice => USD/XYZ, externalRate => XYZ/ABC\n      externalRate = sourcePrice / destinationPrice\n    }\n\n    // Scale rate and apply slippage\n    // prettier-ignore\n    externalRate =\n      externalRate *\n      (1 - slippage) *\n      10 ** (destinationAsset.scale - sourceAsset.scale)\n  }\n\n  const minExchangeRate = Ratio.from(externalRate as NonNegativeRational)\n  log.debug('calculated min exchange rate of %s', minExchangeRate)\n\n  // Perform rate probe: probe realized rate and discover path max packet amount\n  log.debug('starting quote.')\n  const rateProbeResult = await rateProbe.start()\n  if (isPaymentError(rateProbeResult)) {\n    throw rateProbeResult\n  }\n  log.debug('quote complete.')\n\n  // Set the amounts to pay/deliver and perform checks to determine\n  // if this is possible given the probed & minimum rates\n  const { lowEstimatedExchangeRate, highEstimatedExchangeRate, maxPacketAmount } = rateProbeResult\n\n  // From rate probe, source amount of lowerBoundRate should be the maxPacketAmount.\n  // So, no rounding error is possible as long as minRate is at least the probed rate.\n  // ceil(maxPacketAmount * minExchangeRate) >= floor(maxPacketAmount * lowerBoundRate)\n  // ceil(maxPacketAmount * minExchangeRate) >= lowerBoundRate.delivered\n  if (!lowEstimatedExchangeRate.isGreaterThanOrEqualTo(minExchangeRate)) {\n    log.debug(\n      'quote failed: probed exchange rate of %s does not exceed minimum of %s',\n      lowEstimatedExchangeRate,\n      minExchangeRate\n    )\n    throw PaymentError.InsufficientExchangeRate\n  }\n\n  // At each hop, up to 1 unit of the local asset before the conversion\n  // is \"lost\" to rounding when the outgoing amount is floored.\n  // If a small packet is sent, such as the final one in the payment,\n  // it may not meet its minimum destination amount since the rounding\n  // error caused a shortfall.\n\n  // To address this, allow up to 1 source unit to *not* be delivered.\n  // This is accounted for and allowed within the quoted maximum source amount.\n\n  let maxSourceAmount: PositiveInt\n  let minDeliveryAmount: Int\n\n  if (target.type === PaymentType.FixedSend) {\n    maxSourceAmount = target.amount\n    minDeliveryAmount = target.amount.saturatingSubtract(Int.ONE).multiplyCeil(minExchangeRate)\n  } else if (!minExchangeRate.isPositive()) {\n    log.debug('quote failed: unenforceable payment delivery. min exchange rate is 0')\n    throw PaymentError.UnenforceableDelivery\n  } else {\n    // Consider that we're trying to discover the maximum original integer value that\n    // delivered the target delivery amount. If it converts back into a decimal\n    // source amount, it's safe to floor, since we assume each portion of the target\n    // delivery amount was already ceil-ed and delivered at greater than the minimum rate.\n    //\n    // Then, add one to account for the source unit allowed lost to a rounding error.\n    maxSourceAmount = target.amount.multiplyFloor(minExchangeRate.reciprocal()).add(Int.ONE)\n    minDeliveryAmount = target.amount\n  }\n\n  return {\n    paymentType: target.type,\n    lowEstimatedExchangeRate,\n    highEstimatedExchangeRate,\n    minExchangeRate,\n    maxPacketAmount: maxPacketAmount.value,\n    maxSourceAmount: maxSourceAmount.value,\n    minDeliveryAmount: minDeliveryAmount.value,\n  }\n}\n\n/** Send the payment: send a series of packets to attempt the payment within the completion criteria and limits of the provided quote. */\nexport const pay = async (options: PayOptions): Promise<PaymentProgress> => {\n  const maxSourceAmount = Int.from(options.quote.maxSourceAmount)\n  const minDeliveryAmount = Int.from(options.quote.minDeliveryAmount)\n  const maxPacketAmount = Int.from(options.quote.maxPacketAmount)\n  if (!maxSourceAmount || !maxSourceAmount.isPositive()) throw PaymentError.InvalidQuote\n  if (!minDeliveryAmount) throw PaymentError.InvalidQuote\n  if (!maxPacketAmount || !maxPacketAmount.isPositive()) throw PaymentError.InvalidQuote\n\n  const sender = new PaymentSender({\n    ...options,\n    quote: {\n      ...options.quote,\n      maxSourceAmount,\n      minDeliveryAmount,\n      maxPacketAmount,\n    },\n  })\n  const error = await sender.start()\n\n  return {\n    ...(isPaymentError(error) && { error }),\n    ...sender.getProgress(),\n  }\n}\n\n/** Notify receiver to close the connection */\nexport const closeConnection = async (\n  plugin: Plugin,\n  destination: ResolvedPayment\n): Promise<void> => {\n  await new ConnectionCloser(plugin, destination).start()\n}\n"]}